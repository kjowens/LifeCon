1L == list(1)
1 == list(1)
1 == as.list(1)
??L
help(L)
help(1L)
1l??
1L??
)
rt(5,3)
??rt
help(rt)
source("MyActuarial.R")
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
mus(50)
Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a
plot(a[,2])
plot(a[,1])
help(plot)
plot(a[,2], new=TRUE)
plot(a[,1])
plot(a[,2], new=FALSE)
help(plot)
plot(a[,2], new=TRUE)
plot(a[,1])#
plot(a[,2], new=TRUE)
plot(a[,1])#
par(new=TRUE)#
plot(a[,2])
plot(a[,3])
par(new=TRUE)#
plot(a[,1])#
plot(a[,2])#
plot(a[,3])
plot(a[,1])#
par(new=TRUE)#
plot(a[,2])#
par(new=TRUE)#
plot(a[,3])
par()
plot(a[,1])
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t^2)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.01*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.1*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
plot(a[,1])#
#
plot(a[,3])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.1*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
	0.01*exp(-0.5*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
	0.01*exp(-0.5*t^2)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
library(Rcpp)
Rcpp.package.skeleton("mypackage")
a <- data.frame(x=1:4, y=5:8)
a
a$z <- a
a
b <- list(hi=a, hh=a)
b$hi
b$1
c <- list(a,a)
c
c[1]
b[1]
fun1 <- function(x) x*2
fun1(2)
hi <- list(a=fun1)
hi[1](4)
hi[1]
hi$a(4)
hi
hi[1]
hi[1](4)
hi[[1]](4)
vignette("Rcpp-introduction")
ggkm <- function(sfit,#
                     table = TRUE,#
                     returns = FALSE,#
                     xlabs = "Time",#
                     ylabs = "Survival Probability",#
                     xlims = c(0,max(sfit$time)),#
                     ylims = c(0,1),#
                     ystratalabs = NULL,#
                     ystrataname = NULL,#
                     timeby = 100,#
                     main = "Kaplan-Meier Plot",#
                     pval = TRUE,#
                     subs = NULL,#
                     ...) {#
        ##############
        # libraries ##
        ##############
        require(ggplot2)#
        require(survival)#
        require(gridExtra)#
        ##################################
        # sorting the use of subsetting ##
        ##################################
        times <- seq(0, max(sfit$time), by = timeby)#
        if(is.null(subs)){#
            subs1 <- 1:length(levels(summary(sfit)$strata))#
            subs2 <- 1:length(summary(sfit,censored=T)$strata)#
            subs3 <- 1:length(summary(sfit,times = times,extend = TRUE)$strata)#
        } else{#
            for(i in 1:length(subs)){#
                if(i==1){#
                    ssvar <- paste("(?=.*\\b=",subs[i],sep="")#
                }#
                if(i==length(subs)){#
                    ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],"\\b)",sep="")#
                }#
                if(!i %in% c(1, length(subs))){#
                    ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],sep="")#
                }#
                if(i==1 & i==length(subs)){#
                    ssvar <- paste("(?=.*\\b=",subs[i],"\\b)",sep="")#
                }#
            }#
            subs1 <- which(regexpr(ssvar,levels(summary(sfit)$strata), perl=T)!=-1)#
            subs2 <- which(regexpr(ssvar,summary(sfit,censored=T)$strata, perl=T)!=-1)#
            subs3 <- which(regexpr(ssvar,summary(sfit,times = times,extend = TRUE)$strata, perl=T)!=-1)#
        }#
        if( !is.null(subs) ) pval <- FALSE#
        ###################################
        # data manipulation pre-plotting ##
        ###################################
        if(is.null(ystratalabs)) ystratalabs <- as.character(sub("group=*","",names(sfit$strata))) #[subs1]#
        if(is.null(ystrataname)) ystrataname <- "Strata"#
        m <- max(nchar(ystratalabs))#
        times <- seq(0, max(sfit$time), by = timeby)#
        .df <- data.frame(                      # data to be used in the survival plot#
            time = sfit$time[subs2],#
            n.risk = sfit$n.risk[subs2],#
            n.event = sfit$n.event[subs2],#
            surv = sfit$surv[subs2],#
            strata = factor(summary(sfit, censored = T)$strata[subs2]),#
            upper = sfit$upper[subs2],#
            lower = sfit$lower[subs2]#
        )#
        levels(.df$strata) <- ystratalabs       # final changes to data for survival plot#
        zeros <- data.frame(time = 0, surv = 1,#
                            strata = factor(ystratalabs, levels=levels(.df$strata)),#
                            upper = 1, lower = 1)#
        .df <- rbind.fill(zeros, .df)#
        d <- length(levels(.df$strata))#
        ####################################
        # specifying plot parameteres etc ##
        ####################################
        p <- ggplot( .df, aes(time, surv)) +#
            geom_step(aes(linetype = strata), size = 0.7) +#
            theme_bw() +#
            opts(axis.title.x = theme_text(vjust = 0.5)) +#
            scale_x_continuous(xlabs, breaks = times, limits = xlims) +#
            scale_y_continuous(ylabs, limits = ylims) +#
            opts(panel.grid.minor = theme_blank()) +#
            opts(legend.position = c(ifelse(m < 10, .28, .35),ifelse(d < 4, .25, .35))) +    # MOVE LEGEND HERE [first is x dim, second is y dim]#
            opts(legend.key = theme_rect(colour = NA)) +#
            labs(linetype = ystrataname) +#
            opts(plot.margin = unit(c(0, 1, .5,ifelse(m < 10, 1.5, 2.5)),"lines")) +#
            opts(title = main)#
        ## Create a blank plot for place-holding#
        ## .df <- data.frame()#
        blank.pic <- ggplot(.df, aes(time, surv)) +#
            geom_blank() + theme_bw() +#
            opts(axis.text.x = theme_blank(),axis.text.y = theme_blank(),#
                 axis.title.x = theme_blank(),axis.title.y = theme_blank(),#
                 axis.ticks = theme_blank(),#
                 panel.grid.major = theme_blank(),panel.border = theme_blank())#
        ######################
        # p-value placement ##
        #####################a#
        if(pval) {#
            sdiff <- survdiff(eval(sfit$call$formula), data = eval(sfit$call$data))#
            pval <- pchisq(sdiff$chisq,length(sdiff$n) - 1,lower.tail = FALSE)#
            pvaltxt <- ifelse(pval < 0.0001,"p < 0.0001",paste("p =", signif(pval, 3)))#
            p <- p + annotate("text",x = 0.6 * max(sfit$time),y = 0.1,label = pvaltxt)#
        }#
        ####################################################
        # Create table graphic to include at-risk numbers ##
        ####################################################
        if(table) {#
            risk.data <- data.frame(#
                strata = factor(summary(sfit,times = times,extend = TRUE)$strata[subs3]),#
                time = summary(sfit,times = times,extend = TRUE)$time[subs3],#
                n.risk = summary(sfit,times = times,extend = TRUE)$n.risk[subs3]#
            )#
            risk.data$strata <- factor(risk.data$strata, levels=rev(levels(risk.data$strata)))#
            data.table <- ggplot(risk.data,aes(x = time, y = strata, label = format(n.risk, nsmall = 0))) +#
                #, color = strata)) +#
                geom_text(size = 3.5) + theme_bw() +#
                scale_y_discrete(breaks = as.character(levels(risk.data$strata)),#
                                 labels = rev(ystratalabs)) +#
                                     # scale_y_discrete(#format1ter = abbreviate,#
                                     # breaks = 1:3,#
                                     # labels = ystratalabs) +#
                                     scale_x_continuous("Numbers at risk", limits = xlims) +#
                                     opts(axis.title.x = theme_text(size = 10, vjust = 1),#
                                          panel.grid.major = theme_blank(), panel.grid.minor = theme_blank(),#
                                          panel.border = theme_blank(),axis.text.x = theme_blank(),#
                                          axis.ticks = theme_blank(),axis.text.y = theme_text(face = "bold",hjust = 1))#
            data.table <- data.table +#
                opts(legend.position = "none") + xlab(NULL) + ylab(NULL)#
            data.table <- data.table +#
                opts(plot.margin = unit(c(-1.5, 1, 0.1, ifelse(m < 10, 2.5, 3.5) - 0.28 * m), "lines")) # ADJUST POSITION OF TABLE FOR AT RISK#
            ########################
            # Plotting the graphs ##
            ########################
            ## p <- ggplotGrob(p)#
            ## p <- addGrob(p, textGrob(x = unit(.8, "npc"), y = unit(.25, "npc"), label = pvaltxt,#
            ## gp = gpar(fontsize = 12)))#
            grid.arrange(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
                         ncol = 1, heights = unit(c(2, .1, .25),c("null", "null", "null")))#
            if(returns) {#
                a <- arrangeGrob(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
                                 ncol = 1, heights = unit(c(2, .1, .25), c("null", "null", "null")))#
                return(a)#
            }#
        } else {#
            ## p <- ggplotGrob(p)#
            ## p <- addGrob(p, textGrob(x = unit(0.5, "npc"), y = unit(0.23, "npc"),#
            ## label = pvaltxt, gp = gpar(fontsize = 12)))#
            if(returns) return(p)#
        }#
    }
a <- list(1:2, 3:4)
a
a[]
a[][1]
a[][1] <- 5:6
a[][1]
a
a <- list(1:2, 3:4)
a
a[][1]
a[,1]
3*4*5
a <- array(1:60, dims=c(3,4,5))
a <- as.array(1:60, dims=c(3,4,5))
a
?array
a <- as.array(1:60, dim=c(3,4,5))
a
a[1,,]
a[1,]
is.array(a)
dims(a)
dim(a)
a <- array(1:60, dim=c(3,4,5))
a
dim(a)
dimnames(a)
dimnames(a) <- list(x=letters(1:3),y=letters(1:4),z=letters(1:5))
?letters
letters(1)
letter(1)
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
a
a[b,a,a]
a["b","a","a"]
?paste
paste(1)
paste(a)
a$x
a[x=="b"]
a
a["a",,]
4 %.% 5
a[1,,]
a[2,,]
paste(pi)
a[2,,] <- 1:20
a[2,,]
a[,3,]
a[y=3,,]
a[y==3,,]
dimnames(a)
a$x
a
a[y=2]
y
a <- array(1:60, dim=c(3,4,5))#
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
a
a <- array(1:60, dim=c(3,4,5))#
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
dimnames(a)
a["y"]
a[y]
a[y,,]
a["y",,]
a
a["y",,]
a["a",,]
a[]
a[]$x
dimnames(a)
dimnames(a)$x
z <- list(matrix(1:10, nrow=2), matrix(11:20, nrow=2))#
lapply(z, "[", 1, )#
lapply(z, "[", , 3)
z[1]
z[2]
z <- list(a=matrix(1:10, nrow=2), b=matrix(11:20, nrow=2))
lapply(z, "[", 1, )
z <- list(a=data.frame(1:10, nrow=2), b=data.frame(11:20, nrow=2))
z
z <- list(a=matrix(1:10, nrow=2), b=matrix(11:20, nrow=2))
lapply(z, "$", 1, )
lapply(z, "$", "a", )
lapply(z, "$", "a")
z$a
as.data.frame(z$a)
z$a <- as.data.frame(z$a)
z$b <- as.data.frame(z$b)
z
lapply(z, "$", V1)
lapply(z, "$", "V1")
lapply(z, "$")
z
lapply(z, "$",1)
lapply(z, "$","1")
lapply(z, "[",V2)
lapply(z, "[","V2")
lapply(z, "[",1,)
lapply(z, "[",where(right("V1",1)==4))
lapply(z, "[",which(right("V1",1)==4))
??right
mod(4,2)
modulus(4,2)
??mod
is.even(2)
lapply(z, "[",which(right("V1",1)>3))
lapply(z, "[",which("V1">3))
z
lapply(z, "[","V1">2)
z$a[which(z$a>1)]
z$a[which(z$a["V1"]>1)]
502*40*(9.24-7.25)
52*40*(9.24-7.25)
52*40*(9.24-7.25)*.9
library(lifecontingencies)
x <- 1:10#
q <- rep(.2, length(x))#
df <- as.dataframe(cbind(x,q))#
df
df <- data.frame(cbind(x,q))#
df
as.lifetable(df)
x <- 1:10#
lx <- seq(100,0,20)#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
lx <- seq(100,0,-20)#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
x#
lx
x <- 1:10#
lx <- seq(100,0,-10)#
x#
lx#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
x <- 1:10#
lx <- seq(100,10,-10)#
x#
lx#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
(x)
length(x)
length(lx)
tbl
tbl <- new("lifetable",x lx)
tbl <- new("lifetable",x, lx)
library(lifecontingencies)
x <- 1:10#
lx <- seq(100,10,-10)#
length(x)#
length(lx)#
tbl <- new("lifetable",x, lx)#
tbl
x <- 1:3#
lx <- c(100,50,0)#
length(x)#
length(lx)#
tbl <- new("lifetable",x, lx)#
tbl
soa08
tbllist <- list(tbl, tbl, tbl)
pxt(tbl, x=age)
age <- 90#
pxt(tbl, x=age)
pxt(tbl, x=age, t=1)
library(lifecontingencies)
pxt(tbl, x=age, t=1)
qxt(tbl, x=age, t=1)
tbl
tbl <- soa08#
tbllist <- list(tbl, tbl, tbl)#
age <- 90#
qxt(tbl, x=age, t=1)
pxt(tbl, x=age, t=1)
tbllist <- list(tbl, tbl)#
age <- 100#
pxt(tbl, x=age, t=1)
agelist <- list(age, age)
pxyzt(tbllist, agelist, t=1, status="last survivor")
ages <- c(age, age)#
pxyzt(tbllist, ages, t=1, status="last survivor")
pxyt(tbl, tbl, age, age, t=1, status="last survivor")
qxt(tbl, x=age, t=1)
y <- pxt(tbl, x=age, t=1)
y
2*y - y^2
pxyzt(tbllist3, ages3, t=1, status="last survivor")
ages3 <- c(age, age, age)#
tbllist3 <- list(tbl, tbl, tbl)#
pxyzt(tbllist3, ages3, t=1, status="last survivor")
3*y - 3*y^2 + y^3
help(apply)
mapply(rep, 1:4, 4:1)
X <- list(list(a = pi, b = list(c = 1:1)), d = "a test")#
rapply(X, function(x) x, how = "replace")
x <- list(1:4)
x
rapply(x, sqrt)
x
rapply(x, sqrt, how="replace")#
x
x <- list(1:4, list(5:8))#
x#
rapply(x, sqrt, how="replace")#
x
x <- list(list(1:4), list(5:8))#
x#
rapply(x, sqrt, how="replace")#
x
lapply(x, sqrt)
rapply(x, sqrt, how="list")
mapply(rep, 1:4, 4:1)
help(rep)
mapply(rep, x=1:4, times=4:1)
mapply(rep, times=1:4, x=4:1)
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
pFAA.0 <- function(q, t) {ifelse(t>0,q,0)}#
pFAA.1 <- function(q, t) {ifelse(t<1,0,q)}#
pFAA.2 <- function(q, t) {1-t*q}#
pFAA.3 <- function(q, t) {(1-q)^t}#
pFAA.4 <- function(q, t) {(1-t + t/(1-q))^-1}#
#
pFAA.prep <- function(q, t, FAA) {#
	out <- numeric(1)#
	if(any(q<0,q>1,t<0,t>1, !(FAA %in% 0:4))) {#
		stop("arguments outside of their domain")#
		} else {#
			out <- switch(FAA+1,#
					pFFA.0(q, t),#
					pFFA.1(q, t),#
					pFFA.2(q, t),#
					pFFA.3(q, t),#
					pFFA.4(q, t)#
				)#
		}#
		return(out)#
}#
#
pFAA <- function(q, t, FAA) {#
	mapply(pFAA.prep, q, t, FAA)#
}#
#
library(RUnit)
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
checkException(pFAA(-1, .3, 2))#
	checkException(pFAA(2, .3, 2))#
	checkException(pFAA(.4, -1, 2))#
	checkException(pFAA(.4, 2, 2))#
	checkException(pFAA(.4, .3, -1))#
	checkException(pFAA(.4, .3, 5))#
	checkEquals(pFAA(.4, .3, 0), .4)#
	checkEquals(pFAA(.4, 0, 0), 0)#
	checkEquals(pFAA(.4, .3, 1), 0)#
	checkEquals(pFAA(.4, 1, 0), .4)#
	checkEquals(pFAA(.4, .3, 2), .88)#
	checkEquals(pFAA(.4, .3, 3), .6^.3)#
	checkEquals(pFAA(.4, .3, 4), (.7 + .3/.6)^-1)
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
pFAA.0 <- function(q, t) {ifelse(t>0,q,0)}#
pFAA.1 <- function(q, t) {ifelse(t<1,0,q)}#
pFAA.2 <- function(q, t) {1-t*q}#
pFAA.3 <- function(q, t) {(1-q)^t}#
pFAA.4 <- function(q, t) {(1-t + t/(1-q))^-1}#
#
pFAA.prep <- function(q, t, FAA) {#
	out <- numeric(1)#
	if(any(q<0,q>1,t<0,t>1, !(FAA %in% 0:4))) {#
		stop("arguments outside of their domain")#
		} else {#
			out <- switch(FAA+1,#
					pFFA.0(q, t),#
					pFFA.1(q, t),#
					pFFA.2(q, t),#
					pFFA.3(q, t),#
					pFFA.4(q, t)#
				)#
		}#
		return(out)#
}#
#
pFAA <- function(q, t, FAA) {#
	mapply(pFAA.prep, q, t, FAA)#
}
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
checkException(pFAA(-1, .3, 2))#
	checkException(pFAA(2, .3, 2))#
	checkException(pFAA(.4, -1, 2))#
	checkException(pFAA(.4, 2, 2))#
	checkException(pFAA(.4, .3, -1))#
	checkException(pFAA(.4, .3, 5))#
	checkEquals(pFAA(.4, .3, 0), .4)#
	checkEquals(pFAA(.4, 0, 0), 0)#
	checkEquals(pFAA(.4, .3, 1), 0)#
	checkEquals(pFAA(.4, 1, 0), .4)#
	checkEquals(pFAA(.4, .3, 2), .88)#
	checkEquals(pFAA(.4, .3, 3), .6^.3)#
	checkEquals(pFAA(.4, .3, 4), (.7 + .3/.6)^-1)
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
checkException(pFAA(-1, .3, 2))#
	checkException(pFAA(2, .3, 2))#
	checkException(pFAA(.4, -1, 2))#
	checkException(pFAA(.4, 2, 2))#
	checkException(pFAA(.4, .3, -1))#
	checkException(pFAA(.4, .3, 5))#
	checkEquals(pFAA(.4, .3, 0), .4)#
	checkEquals(pFAA(.4, 0, 0), 0)#
	checkEquals(pFAA(.4, .3, 1), 0)#
	checkEquals(pFAA(.4, 1, 0), .4)#
	checkEquals(pFAA(.4, .3, 2), .88)#
	checkEquals(pFAA(.4, .3, 3), .6^.3)#
	checkEquals(pFAA(.4, .3, 4), (.7 + .3/.6)^-1)
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
pFAA.0 <- function(q, t) {ifelse(t>0,q,0)}#
pFAA.1 <- function(q, t) {ifelse(t<1,0,q)}#
pFAA.2 <- function(q, t) {1-t*q}#
pFAA.3 <- function(q, t) {(1-q)^t}#
pFAA.4 <- function(q, t) {(1-t + t/(1-q))^-1}#
#
pFAA.prep <- function(q, t, FAA) {#
	out <- numeric(1)#
	if(any(q<0,q>1,t<0,t>1, !(FAA %in% 0:4))) {#
		stop("arguments outside of their domain")#
		} else {#
			out <- switch(FAA+1,#
					pFAA.0(q, t),#
					pFAA.1(q, t),#
					pFAA.2(q, t),#
					pFAA.3(q, t),#
					pFAA.4(q, t)#
				)#
		}#
		return(out)#
}#
#
pFAA <- function(q, t, FAA) {#
	mapply(pFAA.prep, q, t, FAA)#
}
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
checkException(pFAA(-1, .3, 2))#
	checkException(pFAA(2, .3, 2))#
	checkException(pFAA(.4, -1, 2))#
	checkException(pFAA(.4, 2, 2))#
	checkException(pFAA(.4, .3, -1))#
	checkException(pFAA(.4, .3, 5))#
	checkEquals(pFAA(.4, .3, 0), .4)#
	checkEquals(pFAA(.4, 0, 0), 0)#
	checkEquals(pFAA(.4, .3, 1), 0)#
	checkEquals(pFAA(.4, 1, 0), .4)#
	checkEquals(pFAA(.4, .3, 2), .88)#
	checkEquals(pFAA(.4, .3, 3), .6^.3)#
	checkEquals(pFAA(.4, .3, 4), (.7 + .3/.6)^-1)
