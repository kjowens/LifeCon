t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period
t
mus.t <- mus(t)
mus.t
pijs.t <- ps[period-1,,]
pijs.t
horizon <- 1#
h <- .2#
n <- horizon/h + 1 # + 1 for time zero#
ts <- seq(from=0, to=horizon, by=h)#
ps <- array(data=rep(0, times=(length(p.start)*n)),#
			dim=c(n, length(p.start[1,]), length(p.start[,1])),#
			dimnames=list(as.character(ts), statesNames, statesNames)#
)#
period <- 5#
for (period in 1:length( ps[,1,1] )) {#
	if (period==1) {#
		ps[period,,] <- p.start#
	}#
	else{#
		t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
		mus.t <- mus(t)#
		pijs.t <- ps[period-1,,]#
		#th <- as.numeric(names(ps[,1,1][period])) # the time we want to calc#
		for (i in 1:length( pijs.t[,1] )) {#
			for (j in 1:length( pijs.t[i,] )) {#
				ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
			}#
	}#
	}#
}#
ps[,"Healthy",]
period <- 5
t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period
t
mus.t <- mus(t)
mus.t
pijs.t <- ps[period-1,,]
pijs.t
i=1
j=1
ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)
ps[period,i,j]
pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)
i=i
i
j
mus
mus=mus.t
mus
ps=pijs.t
ps
h=h
h
out <- NULL
pijth <- function( i, j, mus, ps, h)#
{#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}
horizon <- 1#
h <- .2#
n <- horizon/h + 1 # + 1 for time zero#
ts <- seq(from=0, to=horizon, by=h)#
ps <- array(data=rep(0, times=(length(p.start)*n)),#
			dim=c(n, length(p.start[1,]), length(p.start[,1])),#
			dimnames=list(as.character(ts), statesNames, statesNames)#
)#
period <- 5#
for (period in 1:length( ps[,1,1] )) {#
	if (period==1) {#
		ps[period,,] <- p.start#
	}#
	else{#
		t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
		mus.t <- mus(t)#
		pijs.t <- ps[period-1,,]#
		for (i in 1:length( pijs.t[,1] )) {#
			for (j in 1:length( pijs.t[i,] )) {#
				i=1#
				j=1#
				ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
			}#
	}#
	}#
}#
ps[,"Healthy",]
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}
horizon <- 1#
h <- .2#
n <- horizon/h + 1 # + 1 for time zero#
ts <- seq(from=0, to=horizon, by=h)#
ps <- array(data=rep(0, times=(length(p.start)*n)),#
			dim=c(n, length(p.start[1,]), length(p.start[,1])),#
			dimnames=list(as.character(ts), statesNames, statesNames)#
)#
period <- 5#
for (period in 1:length( ps[,1,1] )) {#
	if (period==1) {#
		ps[period,,] <- p.start#
	}#
	else{#
		t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
		mus.t <- mus(t)#
		pijs.t <- ps[period-1,,]#
		for (i in 1:length( pijs.t[,1] )) {#
			for (j in 1:length( pijs.t[i,] )) {#
				i=1#
				j=1#
				ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
			}#
	}#
	}#
}#
ps[,"Healthy",]
ps[n,"Healthy",1]
ps[n,"Healthy",1]/exp(-.1)
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL,  )#
{#
	out <- NULL#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	p.start <- population.start#
	mus <- ForcesofMort#
#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					i=1#
					j=1#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}
Kolmogorov's forward equation, as a single formula#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	p.start <- population.start#
	mus <- ForcesofMort#
#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					i=1#
					j=1#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}
KFE.pijt( horizon=1, h=0.2, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
horizon <- 1#
h <- .01#
n <- horizon/h + 1 # + 1 for time zero#
ts <- seq(from=0, to=horizon, by=h)#
ps <- array(data=rep(0, times=(length(p.start)*n)),#
			dim=c(n, length(p.start[1,]), length(p.start[,1])),#
			dimnames=list(as.character(ts), statesNames, statesNames)#
)#
#
for (period in 1:length( ps[,1,1] )) {#
	if (period==1) {#
		ps[period,,] <- p.start#
	}#
	else{#
		t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
		mus.t <- mus(t)#
		pijs.t <- ps[period-1,,]#
		for (i in 1:length( pijs.t[,1] )) {#
			for (j in 1:length( pijs.t[i,] )) {#
				i=1#
				j=1#
				ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
			}#
	}#
	}#
}#
ps[n,"Healthy",1]/exp(-.1)
ps[n,"Healthy",1]
horizon <- 1#
h <- .2#
n <- horizon/h + 1 # + 1 for time zero#
ts <- seq(from=0, to=horizon, by=h)#
ps <- array(data=rep(0, times=(length(p.start)*n)),#
			dim=c(n, length(p.start[1,]), length(p.start[,1])),#
			dimnames=list(as.character(ts), statesNames, statesNames)#
)#
#
for (period in 1:length( ps[,1,1] )) {#
	if (period==1) {#
		ps[period,,] <- p.start#
	}#
	else{#
		t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
		mus.t <- mus(t)#
		pijs.t <- ps[period-1,,]#
		for (i in 1:length( pijs.t[,1] )) {#
			for (j in 1:length( pijs.t[i,] )) {#
				i=1#
				j=1#
				ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
			}#
	}#
	}#
}#
ps[n,"Healthy",1]#
exp(-.1)#
ps[n,"Healthy",1]/exp(-.1)
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01 - 0.001*t#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
p.start <- matrix(#
	c(1, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=100, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
myps[,"Healthy",]
round(myps[,"Healthy",],5)
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01 - 0.001*t#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}
mus(20)
mus(75)
round(myps[,,"Healthy"],5)
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
round(myps[10,,],5)
Kolmogorov's forward equation, as a single formula#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	p.start <- population.start#
	mus <- ForcesofMort#
#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	#0.03 + 0.002*t#
	0#
}#
#
mu13 <- function( t )#
{#
	#0.005 + 0.001*t#
	.1#
}#
#
mu21 <- function( t )#
{#
	#0.01 - 0.001*t#
	0#
}#
#
mu23 <- function( t )#
{#
	#0.05 + 0.003*t#
	0#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
p.start <- matrix(#
	c(1, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
horizon <- 1#
h <- .2#
n <- horizon/h + 1 # + 1 for time zero#
ts <- seq(from=0, to=horizon, by=h)#
ps <- array(data=rep(0, times=(length(p.start)*n)),#
			dim=c(n, length(p.start[1,]), length(p.start[,1])),#
			dimnames=list(as.character(ts), statesNames, statesNames)#
)#
#
for (period in 1:length( ps[,1,1] )) {#
	if (period==1) {#
		ps[period,,] <- p.start#
	}#
	else{#
		t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
		mus.t <- mus(t)#
		pijs.t <- ps[period-1,,]#
		for (i in 1:length( pijs.t[,1] )) {#
			for (j in 1:length( pijs.t[i,] )) {#
				ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
			}#
	}#
	}#
}#
ps[n,"Healthy",1]#
exp(-.1)#
ps[n,"Healthy",1]/exp(-.1)#
# It's close, even with just five steps
Kolmogorov's forward equation, as a single formula#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	p.start <- population.start#
	mus <- ForcesofMort#
#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Here's a more comlpicated example, using the mu's at the top#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01 - 0.001*t#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
p.start <- matrix(#
	c(1, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
round(myps[10,,],5)#
mus(75)
round(myps[,1,],5)
Kolmogorov's forward equation, as a single formula#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	p.start <- population.start#
	mus <- ForcesofMort#
#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- max(pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h),0)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Here's a more comlpicated example, using the mu's at the top#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01 - 0.001*t#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
p.start <- matrix(#
	c(1, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
round(myps[,1,],5)#
mus(75)
round(myps[,"Healthy",],5)
dimnames(myps[,1,1])
names(myps[,1,1])
list("time", statesNames)
c("time", statesNames)
ps <- array(data=rep(0, times=((length(p.start)+1)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), c("Time", statesNames), c("Time", statesNames))#
	)
horizon <- 1#
h <- .2#
n <- horizon/h + 1 # + 1 for time zero#
ts <- seq(from=0, to=horizon, by=h)
ts
ps <- array(data=rep(0, times=((length(p.start)+1)*n)),#
			dim=c(n, length(p.start[1,]), length(p.start[,1]))#,#
			#dimnames=list(as.character(ts), c("Time", statesNames), c("Time", statesNames))#
)
ps
ps <- array(data=rep(0, times=(length(p.start)*(n+1))),#
			dim=c(n, length(p.start[1,]), length(p.start[,1]))#,#
			#dimnames=list(as.character(ts), c("Time", statesNames), c("Time", statesNames))#
)
ps
ps <- array(data=rep(0, times=(length(p.start)*(n+1))),#
			dim=c(n, length(p.start[1,])+1, length(p.start[,1])+1)#,#
			#dimnames=list(as.character(ts), c("Time", statesNames), c("Time", statesNames))#
)#
ps
ps <- array(data=rep(0, times=((length(p.start)+1)*n)),#
			dim=c(n, length(p.start[1,])+1, length(p.start[,1])+1)#,#
			#dimnames=list(as.character(ts), c("Time", statesNames), c("Time", statesNames))#
)#
ps
ps <- array(data=rep(0, times=(length(p.start)*(n+1))),#
			dim=c(n, length(p.start[1,])+1, length(p.start[,1])+1)#,#
			#dimnames=list(as.character(ts), c("Time", statesNames), c("Time", statesNames))#
)#
ps
Kolmogorov's forward equation, as a single formula#
# I'm going to put time in too, so it's a little different than above#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	p.start <- population.start#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- max(pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h),0)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Here's a more comlpicated example, using the mu's at the top#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01 - 0.001*t#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
p.start <- matrix(#
	c(1, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
round(myps[,"Healthy",],5)#
names(myps[,1,1])
myps <- KFE.pijt( horizon=25, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
round(myps[,"Healthy",],5)#
names(myps[,1,1])
myps[,1,1]
a<-as.df(myps)
a<-as.dataframe(myps)
a<-dataframe(myps)
a<-as.data.frame(myps)
a
round(myps[,"Healthy",],5)
as.numeric(names(myps[,1,1]))
myps$time <- as.numeric(names(myps[,1,1]))
myps[,1,1,]
myps[,1,1]
myps
myps <- KFE.pijt( horizon=1, h=.2, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
round(myps[,"Healthy",],5)
myps[,1,1]
myps[.2,1,1])
myps[".2",1,1])
myps["0.2",1,1])
myps["0.2",1,1]
round(myps[,"Healthy",],5)
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
round(myps[,"Healthy",],5)
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 100, 0,#
	  0, 0, 100#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
round(myps[,"Healthy",],5)
round(myps[,"Disabled",],5)
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 100, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
round(myps[,"Disabled",],5)
round(myps[,,"Dead"],5)
round(myps[,"Healthy",],5)
sum(round(myps[5,"Healthy",],5))
sum(round(myps[51,"Healthy",],5))
sum(round(myps[50,"Healthy",],5))
Start with 100 healthy people and 100 disabled people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
sum(round(myps[50,"Healthy",],5))
sum(round(myps[25,"Healthy",],5))
sum(round(myps[40,"Healthy",],5))
sum(round(myps[45,"Healthy",],5))
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 2, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)
sum(p.start)
Kolmogorov's forward equation, as a single formula#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- min(max(pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h),0),TotalPopulation)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Here's a more comlpicated example, using the mu's at the top#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01 - 0.001*t#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people and 100 disabled people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
sum(round(myps[45,"Healthy",],5))
round(myps[45,,],5)
round(myps[10,,],5)
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 50, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
round(myps[10,,],5)
sum(round(myps[10,,],5))
sum(round(myps[50,,],5))
round(myps[50,,],5)
myps[50,,]
sum(myps[50,,])
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
					#min(max(pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h),0),TotalPopulation)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Here's a more comlpicated example, using the mu's at the top#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01 - 0.001*t#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people and 100 disabled people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 50, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
sum(myps[50,,])
myps[50,,]
mus(50)
mu21 <- function( t )#
{#
	max(0.01 - 0.001*t,0)#
}
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]#
mus(50)
sum(myps[50,,])
round(myps[,"Healthy",],5)
a <- round(myps[,"Healthy",],5)
a[1,]
a[,1]
plot(a[,1])
plot(a[,2])
plot(a[,3])
mu12 <- function( t )#
{#
	0.03 + 0.002*t^2#
}
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]
a <- round(myps[,"Healthy",],5)
a
sum(a[50,])
plot(a[,1])
plot(a[,2])
plot(a[,3])
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}
p.start <- matrix(#
	c(100, 0, 0,#
	  0, , 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]
Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]
sum(myps[50,,])
round(myps[,"Disabled",],5)
round(myps[,"Healthy",],5)
round(myps[,,"Disabled"],5)
plot(a[,1])
plot(a[,2])
mu21 <- function( t )#
{#
	max(0.1 - 0.001*t,0)#
}
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]#
sum(myps[50,,])#
mus(50)
round(myps[,"Healthy",],5)
a <- round(myps[,"Healthy",],5)
plot(a[,1])
plot(a[,2])
plot(a[,3])
plot(a[,2])
mu21 <- function( t )#
{#
	max(0.1 - 0.005*t,0)#
}
Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]#
sum(myps[50,,])#
mus(50)#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,1])#
plot(a[,2])
plot(a[,1])
plot(a[,2])
plot(a[,3])
Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
#
# Kolmogorov's forward equation, as a single formula#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Here's a more comlpicated example, using the mu's at the top#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	max(0.1 - 0.005*t,0)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]#
sum(myps[50,,])#
mus(50)#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,1])#
plot(a[,2])#
plot(a[,3])
library(lifecontingencies)#
library(rbenchmark)
library(lifecontingencies)#
library(rbenchmark)#
data("soa08Act")#
#
i <- 0.1#
#
## Backward Linear First Order Recurrence - takes care of insurance#
## Final boundary value is bv#
## The recurrence is x_n = r_n + s_n * x_{n+1}#
## Handles Annuity & Insurance Recurrence; Fackler; Hattendorff;#
## Must be implemented in C#
#
        BLFOR<-function(r,s,bv)#
            {#
                temp<-bv;#
                dum<-function(x){#
                    temp<<-x[1]+x[2]*temp#
                }#
                as.array(apply(cbind(array(r,dim=length(s)),array(s))[length(s):1,],1,FUN=dum)[length(s):1]);#
            }#
#
soa08Act#
#
method1 <- function( n )#
{#
	for (j in 1:n) {#
		Axn(soa08Act, x=0,i=i)#
	}#
}#
#
# A little algebra to get the input for method2#
# It uses q's rather than p's of the lifetable#
p0 <- soa08Act@lx/soa08Act@lx[1]#
q <- (p0[1:110] - p0[2:111])/p0[1:110]#
#
method2 <- function( n )#
{#
	for (j in 1:n) {#
		BLFOR(q/(1+i),(1-q)/(1+i),1)#
	}#
}#
#
A1 <- Axn(soa08Act, x=0,i=i)#
A2 <- BLFOR(q/1.1,(1-q)/1.1,1)#
A1#
A2#
A2[1]#
A1 - A2[1]#
# There is some floating point error going on, but they more or less get to the same answer.#
#
n <- 100#
#
res <- benchmark(method1(n),#
                 method2(n),#
                 order="relative",#
                 replications = 5)#
print(res[,1:4])#
#
# Let's try to write BLFOR in C++#
library(inline)#
#
# This would need to get cleaned up, but basically works#
src <- '#
Rcpp::NumericVector cr(r);#
Rcpp::NumericVector cs(s);#
Rcpp::NumericVector out(Rcpp::clone(r));#
double temp = Rcpp::as<double>(bv);#
for (int i=cr.size()-1; i>=0; --i) {#
        out[i] = cr[i] + cs[i]*temp;#
        temp = out[i];#
    }#
return Rcpp::wrap(out);'#
BLFORRcpp <- cxxfunction(signature(r="numeric", s="numeric", bv="numeric"), src, plugin="Rcpp")#
BLFORRcpp(q/1.1,(1-q)/1.1,1)#
A2#
prod(BLFORRcpp(q/1.1,(1-q)/1.1,1)==A2)#
# It works#
#
method3 <- function( n )#
{#
	for (j in 1:n) {#
		BLFORRcpp(q/1.1,(1-q)/1.1,1)#
	}#
}#
#
n <- 100#
#
res <- benchmark(method1(n),#
                 method2(n),#
                 method3(n),#
                 order="relative",#
                 replications = 5)#
print(res[,1:4])#
# ... So, it is *a lot* faster in c++
1L:3L
1:3
1L
1
1L == list(1)
1 == list(1)
1 == as.list(1)
??L
help(L)
help(1L)
1l??
1L??
)
rt(5,3)
??rt
help(rt)
source("MyActuarial.R")
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
mus(50)
Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a
plot(a[,2])
plot(a[,1])
help(plot)
plot(a[,2], new=TRUE)
plot(a[,1])
plot(a[,2], new=FALSE)
help(plot)
plot(a[,2], new=TRUE)
plot(a[,1])#
plot(a[,2], new=TRUE)
plot(a[,1])#
par(new=TRUE)#
plot(a[,2])
plot(a[,3])
par(new=TRUE)#
plot(a[,1])#
plot(a[,2])#
plot(a[,3])
plot(a[,1])#
par(new=TRUE)#
plot(a[,2])#
par(new=TRUE)#
plot(a[,3])
par()
plot(a[,1])
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t^2)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.01*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.1*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
plot(a[,1])#
#
plot(a[,3])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.1*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
	0.01*exp(-0.5*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
	0.01*exp(-0.5*t^2)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
library(Rcpp)
Rcpp.package.skeleton("mypackage")
a <- data.frame(x=1:4, y=5:8)
a
a$z <- a
a
b <- list(hi=a, hh=a)
b$hi
b$1
c <- list(a,a)
c
c[1]
b[1]
fun1 <- function(x) x*2
fun1(2)
hi <- list(a=fun1)
hi[1](4)
hi[1]
hi$a(4)
hi
hi[1]
hi[1](4)
hi[[1]](4)
vignette("Rcpp-introduction")
ggkm <- function(sfit,#
                     table = TRUE,#
                     returns = FALSE,#
                     xlabs = "Time",#
                     ylabs = "Survival Probability",#
                     xlims = c(0,max(sfit$time)),#
                     ylims = c(0,1),#
                     ystratalabs = NULL,#
                     ystrataname = NULL,#
                     timeby = 100,#
                     main = "Kaplan-Meier Plot",#
                     pval = TRUE,#
                     subs = NULL,#
                     ...) {#
        ##############
        # libraries ##
        ##############
        require(ggplot2)#
        require(survival)#
        require(gridExtra)#
        ##################################
        # sorting the use of subsetting ##
        ##################################
        times <- seq(0, max(sfit$time), by = timeby)#
        if(is.null(subs)){#
            subs1 <- 1:length(levels(summary(sfit)$strata))#
            subs2 <- 1:length(summary(sfit,censored=T)$strata)#
            subs3 <- 1:length(summary(sfit,times = times,extend = TRUE)$strata)#
        } else{#
            for(i in 1:length(subs)){#
                if(i==1){#
                    ssvar <- paste("(?=.*\\b=",subs[i],sep="")#
                }#
                if(i==length(subs)){#
                    ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],"\\b)",sep="")#
                }#
                if(!i %in% c(1, length(subs))){#
                    ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],sep="")#
                }#
                if(i==1 & i==length(subs)){#
                    ssvar <- paste("(?=.*\\b=",subs[i],"\\b)",sep="")#
                }#
            }#
            subs1 <- which(regexpr(ssvar,levels(summary(sfit)$strata), perl=T)!=-1)#
            subs2 <- which(regexpr(ssvar,summary(sfit,censored=T)$strata, perl=T)!=-1)#
            subs3 <- which(regexpr(ssvar,summary(sfit,times = times,extend = TRUE)$strata, perl=T)!=-1)#
        }#
        if( !is.null(subs) ) pval <- FALSE#
        ###################################
        # data manipulation pre-plotting ##
        ###################################
        if(is.null(ystratalabs)) ystratalabs <- as.character(sub("group=*","",names(sfit$strata))) #[subs1]#
        if(is.null(ystrataname)) ystrataname <- "Strata"#
        m <- max(nchar(ystratalabs))#
        times <- seq(0, max(sfit$time), by = timeby)#
        .df <- data.frame(                      # data to be used in the survival plot#
            time = sfit$time[subs2],#
            n.risk = sfit$n.risk[subs2],#
            n.event = sfit$n.event[subs2],#
            surv = sfit$surv[subs2],#
            strata = factor(summary(sfit, censored = T)$strata[subs2]),#
            upper = sfit$upper[subs2],#
            lower = sfit$lower[subs2]#
        )#
        levels(.df$strata) <- ystratalabs       # final changes to data for survival plot#
        zeros <- data.frame(time = 0, surv = 1,#
                            strata = factor(ystratalabs, levels=levels(.df$strata)),#
                            upper = 1, lower = 1)#
        .df <- rbind.fill(zeros, .df)#
        d <- length(levels(.df$strata))#
        ####################################
        # specifying plot parameteres etc ##
        ####################################
        p <- ggplot( .df, aes(time, surv)) +#
            geom_step(aes(linetype = strata), size = 0.7) +#
            theme_bw() +#
            opts(axis.title.x = theme_text(vjust = 0.5)) +#
            scale_x_continuous(xlabs, breaks = times, limits = xlims) +#
            scale_y_continuous(ylabs, limits = ylims) +#
            opts(panel.grid.minor = theme_blank()) +#
            opts(legend.position = c(ifelse(m < 10, .28, .35),ifelse(d < 4, .25, .35))) +    # MOVE LEGEND HERE [first is x dim, second is y dim]#
            opts(legend.key = theme_rect(colour = NA)) +#
            labs(linetype = ystrataname) +#
            opts(plot.margin = unit(c(0, 1, .5,ifelse(m < 10, 1.5, 2.5)),"lines")) +#
            opts(title = main)#
        ## Create a blank plot for place-holding#
        ## .df <- data.frame()#
        blank.pic <- ggplot(.df, aes(time, surv)) +#
            geom_blank() + theme_bw() +#
            opts(axis.text.x = theme_blank(),axis.text.y = theme_blank(),#
                 axis.title.x = theme_blank(),axis.title.y = theme_blank(),#
                 axis.ticks = theme_blank(),#
                 panel.grid.major = theme_blank(),panel.border = theme_blank())#
        ######################
        # p-value placement ##
        #####################a#
        if(pval) {#
            sdiff <- survdiff(eval(sfit$call$formula), data = eval(sfit$call$data))#
            pval <- pchisq(sdiff$chisq,length(sdiff$n) - 1,lower.tail = FALSE)#
            pvaltxt <- ifelse(pval < 0.0001,"p < 0.0001",paste("p =", signif(pval, 3)))#
            p <- p + annotate("text",x = 0.6 * max(sfit$time),y = 0.1,label = pvaltxt)#
        }#
        ####################################################
        # Create table graphic to include at-risk numbers ##
        ####################################################
        if(table) {#
            risk.data <- data.frame(#
                strata = factor(summary(sfit,times = times,extend = TRUE)$strata[subs3]),#
                time = summary(sfit,times = times,extend = TRUE)$time[subs3],#
                n.risk = summary(sfit,times = times,extend = TRUE)$n.risk[subs3]#
            )#
            risk.data$strata <- factor(risk.data$strata, levels=rev(levels(risk.data$strata)))#
            data.table <- ggplot(risk.data,aes(x = time, y = strata, label = format(n.risk, nsmall = 0))) +#
                #, color = strata)) +#
                geom_text(size = 3.5) + theme_bw() +#
                scale_y_discrete(breaks = as.character(levels(risk.data$strata)),#
                                 labels = rev(ystratalabs)) +#
                                     # scale_y_discrete(#format1ter = abbreviate,#
                                     # breaks = 1:3,#
                                     # labels = ystratalabs) +#
                                     scale_x_continuous("Numbers at risk", limits = xlims) +#
                                     opts(axis.title.x = theme_text(size = 10, vjust = 1),#
                                          panel.grid.major = theme_blank(), panel.grid.minor = theme_blank(),#
                                          panel.border = theme_blank(),axis.text.x = theme_blank(),#
                                          axis.ticks = theme_blank(),axis.text.y = theme_text(face = "bold",hjust = 1))#
            data.table <- data.table +#
                opts(legend.position = "none") + xlab(NULL) + ylab(NULL)#
            data.table <- data.table +#
                opts(plot.margin = unit(c(-1.5, 1, 0.1, ifelse(m < 10, 2.5, 3.5) - 0.28 * m), "lines")) # ADJUST POSITION OF TABLE FOR AT RISK#
            ########################
            # Plotting the graphs ##
            ########################
            ## p <- ggplotGrob(p)#
            ## p <- addGrob(p, textGrob(x = unit(.8, "npc"), y = unit(.25, "npc"), label = pvaltxt,#
            ## gp = gpar(fontsize = 12)))#
            grid.arrange(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
                         ncol = 1, heights = unit(c(2, .1, .25),c("null", "null", "null")))#
            if(returns) {#
                a <- arrangeGrob(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
                                 ncol = 1, heights = unit(c(2, .1, .25), c("null", "null", "null")))#
                return(a)#
            }#
        } else {#
            ## p <- ggplotGrob(p)#
            ## p <- addGrob(p, textGrob(x = unit(0.5, "npc"), y = unit(0.23, "npc"),#
            ## label = pvaltxt, gp = gpar(fontsize = 12)))#
            if(returns) return(p)#
        }#
    }
data(cars)
cars
names(cars)
length(names(cars))
names(cars)[1]
??dfapply
setwd('/Volumes/amy/LifeCon/non_standard/examples')
d <- data.frame(u=1:10, v=rnorm(10), +#
                y=LETTERS[1:10], z=c(rep("A",5),rep("B",5)))#
dapply(d[c("u","v")], by=d[c("y","z")], +#
       FUN=function(x) {idx<-which(max(x)); +#
                        data.frame(max=x[idx],vatmax=v[idx])})
setwd('/Volumes/amy/LifeCon/non_standard/examples')
d <- data.frame(u=1:10, v=rnorm(10),#
                y=LETTERS[1:10], z=c(rep("A",5),rep("B",5)))
setwd('/Volumes/amy/LifeCon/non_standard/examples')
d
setwd('/Volumes/amy/LifeCon/non_standard/examples')
dapply(d[c("u","v")], by=d[c("y","z")], #
       FUN=function(x) {idx<-which(max(x)); #
                        data.frame(max=x[idx],vatmax=v[idx])})
setwd('/Volumes/amy/LifeCon/non_standard/examples')
library(heR.Misc)
