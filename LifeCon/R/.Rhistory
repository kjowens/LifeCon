Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]
sum(myps[50,,])
round(myps[,"Disabled",],5)
round(myps[,"Healthy",],5)
round(myps[,,"Disabled"],5)
plot(a[,1])
plot(a[,2])
mu21 <- function( t )#
{#
	max(0.1 - 0.001*t,0)#
}
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]#
sum(myps[50,,])#
mus(50)
round(myps[,"Healthy",],5)
a <- round(myps[,"Healthy",],5)
plot(a[,1])
plot(a[,2])
plot(a[,3])
plot(a[,2])
mu21 <- function( t )#
{#
	max(0.1 - 0.005*t,0)#
}
Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]#
sum(myps[50,,])#
mus(50)#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,1])#
plot(a[,2])
plot(a[,1])
plot(a[,2])
plot(a[,3])
Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
#
# Kolmogorov's forward equation, as a single formula#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Here's a more comlpicated example, using the mu's at the top#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	max(0.1 - 0.005*t,0)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
# Where healthy people go over time#
myps[50,,]#
sum(myps[50,,])#
mus(50)#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,1])#
plot(a[,2])#
plot(a[,3])
library(lifecontingencies)#
library(rbenchmark)
library(lifecontingencies)#
library(rbenchmark)#
data("soa08Act")#
#
i <- 0.1#
#
## Backward Linear First Order Recurrence - takes care of insurance#
## Final boundary value is bv#
## The recurrence is x_n = r_n + s_n * x_{n+1}#
## Handles Annuity & Insurance Recurrence; Fackler; Hattendorff;#
## Must be implemented in C#
#
        BLFOR<-function(r,s,bv)#
            {#
                temp<-bv;#
                dum<-function(x){#
                    temp<<-x[1]+x[2]*temp#
                }#
                as.array(apply(cbind(array(r,dim=length(s)),array(s))[length(s):1,],1,FUN=dum)[length(s):1]);#
            }#
#
soa08Act#
#
method1 <- function( n )#
{#
	for (j in 1:n) {#
		Axn(soa08Act, x=0,i=i)#
	}#
}#
#
# A little algebra to get the input for method2#
# It uses q's rather than p's of the lifetable#
p0 <- soa08Act@lx/soa08Act@lx[1]#
q <- (p0[1:110] - p0[2:111])/p0[1:110]#
#
method2 <- function( n )#
{#
	for (j in 1:n) {#
		BLFOR(q/(1+i),(1-q)/(1+i),1)#
	}#
}#
#
A1 <- Axn(soa08Act, x=0,i=i)#
A2 <- BLFOR(q/1.1,(1-q)/1.1,1)#
A1#
A2#
A2[1]#
A1 - A2[1]#
# There is some floating point error going on, but they more or less get to the same answer.#
#
n <- 100#
#
res <- benchmark(method1(n),#
                 method2(n),#
                 order="relative",#
                 replications = 5)#
print(res[,1:4])#
#
# Let's try to write BLFOR in C++#
library(inline)#
#
# This would need to get cleaned up, but basically works#
src <- '#
Rcpp::NumericVector cr(r);#
Rcpp::NumericVector cs(s);#
Rcpp::NumericVector out(Rcpp::clone(r));#
double temp = Rcpp::as<double>(bv);#
for (int i=cr.size()-1; i>=0; --i) {#
        out[i] = cr[i] + cs[i]*temp;#
        temp = out[i];#
    }#
return Rcpp::wrap(out);'#
BLFORRcpp <- cxxfunction(signature(r="numeric", s="numeric", bv="numeric"), src, plugin="Rcpp")#
BLFORRcpp(q/1.1,(1-q)/1.1,1)#
A2#
prod(BLFORRcpp(q/1.1,(1-q)/1.1,1)==A2)#
# It works#
#
method3 <- function( n )#
{#
	for (j in 1:n) {#
		BLFORRcpp(q/1.1,(1-q)/1.1,1)#
	}#
}#
#
n <- 100#
#
res <- benchmark(method1(n),#
                 method2(n),#
                 method3(n),#
                 order="relative",#
                 replications = 5)#
print(res[,1:4])#
# ... So, it is *a lot* faster in c++
1L:3L
1:3
1L
1
1L == list(1)
1 == list(1)
1 == as.list(1)
??L
help(L)
help(1L)
1l??
1L??
)
rt(5,3)
??rt
help(rt)
source("MyActuarial.R")
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	if(k==j) {Stop(Error: k should not equal j)}#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}
This example uses Kolmogorov's forward equation to numerically estimate transition probabilities for non-homogonous Markov chains.#
.ChangeFrom.k <- function( i, j, mus, ps, k )#
{#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# k: the state under consideration#
	# Output:#
		# The change due to state k, k not equal to j#
	out <- NULL#
	out <- ps[i,k]*mus[k,j] - ps[i,j]*mus[j,k]#
	return(out)#
}#
#
pijth <- function( i, j, mus, ps, h)#
{#
	# Probability state transition from i to j at time t+h given prob for time t#
	# Inputs:#
		# i: starting state#
		# j: ending state#
		# mus: matrix of hazard rates as a function of time#
		# ps: matrix of state probabilities from the last iteration#
		# h: the length of the period#
	# Output:#
		# probability that one starting in state i will be in state j at t+h#
	out <- NULL#
	pijt <- ps[i,j]#
	changes <- rep(0, times=length( mus[1,]) - 1 )#
	for (k in 1:length( mus[1,]) ) {#
		if (k!=j) {#
			changes[k] <- .ChangeFrom.k( i=i, j=j, mus=mus, ps=ps, k=k )#
		}#
	}#
	out <- pijt + h*sum(changes)#
	return(out)#
}#
KFE.pijt <- function( horizon=1, h=0.2, population.start, ForcesofMort, statesNames=NULL  )#
{#
	# Kolmogorov's forward equation, as a single formula#
	out <- NULL#
	p.start <- population.start#
	TotalPopulation <- sum(p.start)#
	mus <- ForcesofMort#
	horizon <- horizon#
	h <- h#
	n <- horizon/h + 1 # + 1 for time zero#
	ts <- seq(from=0, to=horizon, by=h)#
	# making the output objet and filling with zeroes#
	ps <- array(data=rep(0, times=(length(p.start)*n)),#
				dim=c(n, length(p.start[1,]), length(p.start[,1])),#
				dimnames=list(as.character(ts), statesNames, statesNames)#
	)#
	for (period in 1:length( ps[,1,1] )) {#
		if (period==1) {#
			ps[period,,] <- p.start#
		}#
		else{#
			t <- as.numeric(names(ps[,1,1][period-1])) # the previous time period#
			mus.t <- mus(t)#
			pijs.t <- ps[period-1,,]#
			for (i in 1:length( pijs.t[,1] )) {#
				for (j in 1:length( pijs.t[i,] )) {#
					ps[period,i,j] <- pijth( i=i, j=j, mus=mus.t, ps=pijs.t, h=h)#
				}#
		}#
		}#
	}#
	out <- ps#
	return(out)#
}#
#
# Define force of mortality functions#
# States:#
#	1 = Healthy#
#	2 = Disabled#
#	3 = Dead#
#
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )
mus(50)
Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a
plot(a[,2])
plot(a[,1])
help(plot)
plot(a[,2], new=TRUE)
plot(a[,1])
plot(a[,2], new=FALSE)
help(plot)
plot(a[,2], new=TRUE)
plot(a[,1])#
plot(a[,2], new=TRUE)
plot(a[,1])#
par(new=TRUE)#
plot(a[,2])
plot(a[,3])
par(new=TRUE)#
plot(a[,1])#
plot(a[,2])#
plot(a[,3])
plot(a[,1])#
par(new=TRUE)#
plot(a[,2])#
par(new=TRUE)#
plot(a[,3])
par()
plot(a[,1])
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.05*t^2)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.01*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.1*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
plot(a[,1])#
#
plot(a[,3])
statesNames <- c("Healthy", "Disabled", "Dead")#
#
mu12 <- function( t )#
{#
	0.03 + 0.002*t#
}#
#
mu13 <- function( t )#
{#
	0.005 + 0.001*t#
}#
#
mu21 <- function( t )#
{#
	0.01*exp(-0.1*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
	0.01*exp(-0.5*t)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
	0.01*exp(-0.5*t^2)#
}#
#
mu23 <- function( t )#
{#
	0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
	out <- matrix(#
			c(0, mu12(t), mu13(t),#
			  mu21(t), 0, mu23(t),#
			  0, 0, 0#
			),#
			nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
		)#
	return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
	c(100, 0, 0,#
	  0, 0, 0,#
	  0, 0, 0#
	),#
	nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
library(Rcpp)
Rcpp.package.skeleton("mypackage")
a <- data.frame(x=1:4, y=5:8)
a
a$z <- a
a
b <- list(hi=a, hh=a)
b$hi
b$1
c <- list(a,a)
c
c[1]
b[1]
fun1 <- function(x) x*2
fun1(2)
hi <- list(a=fun1)
hi[1](4)
hi[1]
hi$a(4)
hi
hi[1]
hi[1](4)
hi[[1]](4)
vignette("Rcpp-introduction")
ggkm <- function(sfit,#
                     table = TRUE,#
                     returns = FALSE,#
                     xlabs = "Time",#
                     ylabs = "Survival Probability",#
                     xlims = c(0,max(sfit$time)),#
                     ylims = c(0,1),#
                     ystratalabs = NULL,#
                     ystrataname = NULL,#
                     timeby = 100,#
                     main = "Kaplan-Meier Plot",#
                     pval = TRUE,#
                     subs = NULL,#
                     ...) {#
        ##############
        # libraries ##
        ##############
        require(ggplot2)#
        require(survival)#
        require(gridExtra)#
        ##################################
        # sorting the use of subsetting ##
        ##################################
        times <- seq(0, max(sfit$time), by = timeby)#
        if(is.null(subs)){#
            subs1 <- 1:length(levels(summary(sfit)$strata))#
            subs2 <- 1:length(summary(sfit,censored=T)$strata)#
            subs3 <- 1:length(summary(sfit,times = times,extend = TRUE)$strata)#
        } else{#
            for(i in 1:length(subs)){#
                if(i==1){#
                    ssvar <- paste("(?=.*\\b=",subs[i],sep="")#
                }#
                if(i==length(subs)){#
                    ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],"\\b)",sep="")#
                }#
                if(!i %in% c(1, length(subs))){#
                    ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],sep="")#
                }#
                if(i==1 & i==length(subs)){#
                    ssvar <- paste("(?=.*\\b=",subs[i],"\\b)",sep="")#
                }#
            }#
            subs1 <- which(regexpr(ssvar,levels(summary(sfit)$strata), perl=T)!=-1)#
            subs2 <- which(regexpr(ssvar,summary(sfit,censored=T)$strata, perl=T)!=-1)#
            subs3 <- which(regexpr(ssvar,summary(sfit,times = times,extend = TRUE)$strata, perl=T)!=-1)#
        }#
        if( !is.null(subs) ) pval <- FALSE#
        ###################################
        # data manipulation pre-plotting ##
        ###################################
        if(is.null(ystratalabs)) ystratalabs <- as.character(sub("group=*","",names(sfit$strata))) #[subs1]#
        if(is.null(ystrataname)) ystrataname <- "Strata"#
        m <- max(nchar(ystratalabs))#
        times <- seq(0, max(sfit$time), by = timeby)#
        .df <- data.frame(                      # data to be used in the survival plot#
            time = sfit$time[subs2],#
            n.risk = sfit$n.risk[subs2],#
            n.event = sfit$n.event[subs2],#
            surv = sfit$surv[subs2],#
            strata = factor(summary(sfit, censored = T)$strata[subs2]),#
            upper = sfit$upper[subs2],#
            lower = sfit$lower[subs2]#
        )#
        levels(.df$strata) <- ystratalabs       # final changes to data for survival plot#
        zeros <- data.frame(time = 0, surv = 1,#
                            strata = factor(ystratalabs, levels=levels(.df$strata)),#
                            upper = 1, lower = 1)#
        .df <- rbind.fill(zeros, .df)#
        d <- length(levels(.df$strata))#
        ####################################
        # specifying plot parameteres etc ##
        ####################################
        p <- ggplot( .df, aes(time, surv)) +#
            geom_step(aes(linetype = strata), size = 0.7) +#
            theme_bw() +#
            opts(axis.title.x = theme_text(vjust = 0.5)) +#
            scale_x_continuous(xlabs, breaks = times, limits = xlims) +#
            scale_y_continuous(ylabs, limits = ylims) +#
            opts(panel.grid.minor = theme_blank()) +#
            opts(legend.position = c(ifelse(m < 10, .28, .35),ifelse(d < 4, .25, .35))) +    # MOVE LEGEND HERE [first is x dim, second is y dim]#
            opts(legend.key = theme_rect(colour = NA)) +#
            labs(linetype = ystrataname) +#
            opts(plot.margin = unit(c(0, 1, .5,ifelse(m < 10, 1.5, 2.5)),"lines")) +#
            opts(title = main)#
        ## Create a blank plot for place-holding#
        ## .df <- data.frame()#
        blank.pic <- ggplot(.df, aes(time, surv)) +#
            geom_blank() + theme_bw() +#
            opts(axis.text.x = theme_blank(),axis.text.y = theme_blank(),#
                 axis.title.x = theme_blank(),axis.title.y = theme_blank(),#
                 axis.ticks = theme_blank(),#
                 panel.grid.major = theme_blank(),panel.border = theme_blank())#
        ######################
        # p-value placement ##
        #####################a#
        if(pval) {#
            sdiff <- survdiff(eval(sfit$call$formula), data = eval(sfit$call$data))#
            pval <- pchisq(sdiff$chisq,length(sdiff$n) - 1,lower.tail = FALSE)#
            pvaltxt <- ifelse(pval < 0.0001,"p < 0.0001",paste("p =", signif(pval, 3)))#
            p <- p + annotate("text",x = 0.6 * max(sfit$time),y = 0.1,label = pvaltxt)#
        }#
        ####################################################
        # Create table graphic to include at-risk numbers ##
        ####################################################
        if(table) {#
            risk.data <- data.frame(#
                strata = factor(summary(sfit,times = times,extend = TRUE)$strata[subs3]),#
                time = summary(sfit,times = times,extend = TRUE)$time[subs3],#
                n.risk = summary(sfit,times = times,extend = TRUE)$n.risk[subs3]#
            )#
            risk.data$strata <- factor(risk.data$strata, levels=rev(levels(risk.data$strata)))#
            data.table <- ggplot(risk.data,aes(x = time, y = strata, label = format(n.risk, nsmall = 0))) +#
                #, color = strata)) +#
                geom_text(size = 3.5) + theme_bw() +#
                scale_y_discrete(breaks = as.character(levels(risk.data$strata)),#
                                 labels = rev(ystratalabs)) +#
                                     # scale_y_discrete(#format1ter = abbreviate,#
                                     # breaks = 1:3,#
                                     # labels = ystratalabs) +#
                                     scale_x_continuous("Numbers at risk", limits = xlims) +#
                                     opts(axis.title.x = theme_text(size = 10, vjust = 1),#
                                          panel.grid.major = theme_blank(), panel.grid.minor = theme_blank(),#
                                          panel.border = theme_blank(),axis.text.x = theme_blank(),#
                                          axis.ticks = theme_blank(),axis.text.y = theme_text(face = "bold",hjust = 1))#
            data.table <- data.table +#
                opts(legend.position = "none") + xlab(NULL) + ylab(NULL)#
            data.table <- data.table +#
                opts(plot.margin = unit(c(-1.5, 1, 0.1, ifelse(m < 10, 2.5, 3.5) - 0.28 * m), "lines")) # ADJUST POSITION OF TABLE FOR AT RISK#
            ########################
            # Plotting the graphs ##
            ########################
            ## p <- ggplotGrob(p)#
            ## p <- addGrob(p, textGrob(x = unit(.8, "npc"), y = unit(.25, "npc"), label = pvaltxt,#
            ## gp = gpar(fontsize = 12)))#
            grid.arrange(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
                         ncol = 1, heights = unit(c(2, .1, .25),c("null", "null", "null")))#
            if(returns) {#
                a <- arrangeGrob(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
                                 ncol = 1, heights = unit(c(2, .1, .25), c("null", "null", "null")))#
                return(a)#
            }#
        } else {#
            ## p <- ggplotGrob(p)#
            ## p <- addGrob(p, textGrob(x = unit(0.5, "npc"), y = unit(0.23, "npc"),#
            ## label = pvaltxt, gp = gpar(fontsize = 12)))#
            if(returns) return(p)#
        }#
    }
a <- list(1:2, 3:4)
a
a[]
a[][1]
a[][1] <- 5:6
a[][1]
a
a <- list(1:2, 3:4)
a
a[][1]
a[,1]
3*4*5
a <- array(1:60, dims=c(3,4,5))
a <- as.array(1:60, dims=c(3,4,5))
a
?array
a <- as.array(1:60, dim=c(3,4,5))
a
a[1,,]
a[1,]
is.array(a)
dims(a)
dim(a)
a <- array(1:60, dim=c(3,4,5))
a
dim(a)
dimnames(a)
dimnames(a) <- list(x=letters(1:3),y=letters(1:4),z=letters(1:5))
?letters
letters(1)
letter(1)
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
a
a[b,a,a]
a["b","a","a"]
?paste
paste(1)
paste(a)
a$x
a[x=="b"]
a
a["a",,]
4 %.% 5
a[1,,]
a[2,,]
paste(pi)
a[2,,] <- 1:20
a[2,,]
a[,3,]
a[y=3,,]
a[y==3,,]
dimnames(a)
a$x
a
a[y=2]
y
a <- array(1:60, dim=c(3,4,5))#
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
a
a <- array(1:60, dim=c(3,4,5))#
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
dimnames(a)
a["y"]
a[y]
a[y,,]
a["y",,]
a
a["y",,]
a["a",,]
a[]
a[]$x
dimnames(a)
dimnames(a)$x
z <- list(matrix(1:10, nrow=2), matrix(11:20, nrow=2))#
lapply(z, "[", 1, )#
lapply(z, "[", , 3)
z[1]
z[2]
z <- list(a=matrix(1:10, nrow=2), b=matrix(11:20, nrow=2))
lapply(z, "[", 1, )
z <- list(a=data.frame(1:10, nrow=2), b=data.frame(11:20, nrow=2))
z
z <- list(a=matrix(1:10, nrow=2), b=matrix(11:20, nrow=2))
lapply(z, "$", 1, )
lapply(z, "$", "a", )
lapply(z, "$", "a")
z$a
as.data.frame(z$a)
z$a <- as.data.frame(z$a)
z$b <- as.data.frame(z$b)
z
lapply(z, "$", V1)
lapply(z, "$", "V1")
lapply(z, "$")
z
lapply(z, "$",1)
lapply(z, "$","1")
lapply(z, "[",V2)
lapply(z, "[","V2")
lapply(z, "[",1,)
lapply(z, "[",where(right("V1",1)==4))
lapply(z, "[",which(right("V1",1)==4))
??right
mod(4,2)
modulus(4,2)
??mod
is.even(2)
lapply(z, "[",which(right("V1",1)>3))
lapply(z, "[",which("V1">3))
z
lapply(z, "[","V1">2)
z$a[which(z$a>1)]
z$a[which(z$a["V1"]>1)]
502*40*(9.24-7.25)
52*40*(9.24-7.25)
52*40*(9.24-7.25)*.9
setwd('/Volumes/amy/LifeCon/LifeCon/R')
RGD<-function(tbl,k)#
                {#
                    n<-length(tbl[,1]);#
                    r<-as.array(runif(k));#
                    for (l in 1:k)#
                    {#
                        u<-r[l];#
                        i<-ceiling(n*u);#
                        if (u>=tbl[i,1]) {#
                            r[l]=i;#
                        }#
                        else {#
                            r[l]=tbl[i,2];#
                            }#
                    }#
                    r#
                }
setwd('/Volumes/amy/LifeCon/non_standard/examples')
q <- c(.3,.4,1)#
f <- SK(q)[1:n]*q#
f#
# it needs to have a terminal age#
sum(SK(q)[1:n]*q)#
f[1]+f[2]#
#
y <- WalkerTable(q)#
y#
sum(y[,1])#
#
set.seed(42)#
RGD(y,k)#
set.seed(42)#
m <- runif(k)#
m[1]#
m[1]*3#
ceiling(m[1]*3)#
y
setwd('/Volumes/amy/LifeCon/non_standard/examples')
q <- c(.3,.4,1)
setwd('/Volumes/amy/LifeCon/non_standard/examples')
f <- SK(q)[1:n]*q
setwd('/Volumes/amy/LifeCon/LifeCon/R')
## The following two functions help simulate K (and hence T)#
## The first function finds the Huffman optimal tree for a given discrete distribution#
## The second function simulates a random vector of size k from the distribution which#
## corresponds to the given Huffman tree.#
#
        ## The following function finds the Huffman optimal tree for a given discrete distribution#
        ## To be used only once for a given mortality table#
#
            HuffmanCode<-function(f)#
                {#
                    n<-dim(f);#
                    Node<-n;#
                    Forest<-cbind(f,1:n);#
                    Tree<-array(0,c(n,4));#
                    Parents<-array(0,c(3*n,20))#
                    NP<-array(1,3*n);#
                    Tree[1:dim(f),4]=f;#
                    while (n>1)#
                    {#
                        x<-order(Forest[,1])[1:2];#
                        Tree<-rbind(Tree,array(c(Forest[x[1],2],Forest[x[2],2],0,Forest[x[1],1]+Forest[x[2],1]),c(1,4)));#
                        Node=Node+1;#
                            Tree[Forest[x[1],2],3]=Node;#
                            Tree[Forest[x[2],2],3]=Node;#
                            Tree[Forest[x[2],2],4]=Forest[x[1],1]+Forest[x[2],1];#
                            Parents[Forest[x[1],2],NP[Forest[x[1],2]]]=Node;#
                            NP[Forest[x[1],2]]=NP[Forest[x[1],2]]+1;#
                            Parents[Forest[x[2],2],NP[Forest[x[2],2]]]=Node;#
                            NP[Forest[x[2],2]]=NP[Forest[x[2],2]]+1;#
                        for (k in 1:Node)#
                        {#
                            if ((any(Parents[k,]==Forest[x[1],2])) || (any(Parents[k,]==Forest[x[2],2])))#
                            {#
                                Parents[k,NP[k]]=Node;#
                                NP[k]=NP[k]+1;#
                                if (any(Parents[k,]==Forest[x[2],2]))#
                                {#
                                    Tree[k,4]=Tree[k,4]+Forest[x[1],1];#
                                }#
                            }#
                        }   #
                        Forest[x[1],]<-array(c(Forest[x[1],1]+Forest[x[2],1],Node),c(1,2));#
                        n=n-1;#
                        Forest<-array(Forest[Forest[,1]!=Forest[x[2],1]],c(n,2));#
                    }#
                    Tree#
                }#
#
        ## The following function builds the tables for the Alias Method of Walker#
            WalkerTable<-function(f)#
                {#
					# f <- SK(q)[1:n]*q#
                    F<-cbind(length(f)*f,1:length(f));#
                    L<-array(0,length(f));#
                    while (length(F[(F[,1]<1)&(F[,1]>0),1])>0) #
                        {#
                            j<-F[(F[,1]<1)&(F[,1]>0),2][1];#
                            k<-F[F[,1]>=1,2][1];#
                            L[j]=k;#
                            F[k,1]=F[k,1]-1+F[j,1];#
                            F[j,1]= - F[j,1];#
                        }#
                    cbind((F[,2]-abs(F[,1]))/length(f),L)#
                }#
#
        ## The following function simulates from a general discrete distribution using the alias method of Walker.#
            RGD<-function(tbl,k)#
                {#
                    n<-length(tbl[,1]);#
                    r<-as.array(runif(k));#
                    for (l in 1:k)#
                    {#
                        u<-r[l];#
                        i<-ceiling(n*u);#
                        if (u>=tbl[i,1]) {#
                            r[l]=i;#
                        }#
                        else {#
                            r[l]=tbl[i,2];#
                            }#
                    }#
                    r#
                }#
#
        ## The following function simulates a random vector of size k from the distribution which#
        ## corresponds to the given Huffman tree. Huffman tree can be found using the above function#
        ## and in fact the two can be combined as#
        ##                                          RGD(HuffmanCode(f),k)#
        ###
#
            RGDHuffman<-function(Tree,k)#
                {#
                    n<-length(Tree)/4;#
                    m<-length(Tree[Tree[,1]==0])/4;#
                    HuffmanDecode<-function(r)#
                        {#
                            nn<-n;#
                            while (nn>m)#
                            {#
                                if (r<Tree[Tree[nn,1],4])#
                                {#
                                    nn=Tree[nn,1];#
                                }#
                                else#
                                {#
                                    nn=Tree[nn,2];#
                                }#
                            }#
                            nn#
                        }#
                    r<-as.array(runif(k));#
                    for (l in 1:k)#
                    {#
                       r[l]<-HuffmanDecode(r[l]);#
                    }#
                    r                        #
                }#
#
        ## The following function simulates from a general discrete distribution using the alias method of Walker.#
            RT<-function(q,FAA,k)#
                {#
                    n<-length(q);#
                    T<-WalkerTable(SK(q)[1:n]*q);#
                    r<-as.array(runif(k));#
                    for (l in 1:k)#
                    {#
                        u<-r[l];#
                        i<-ceiling(n*u);#
                        if (u>=T[i,1]) {#
                            r[l]=i-1+IDF(q[i],FAA,(u-T[i,1])/(1-T[i,1]));#
                        }#
                        else {#
                            r[l]=T[i,2]-1+IDF(q[T[i,2]],FAA,u/T[i,1]);#
                            }#
                    }#
                    r   #
                }#
#
        ## Inverse Distribution Function for fractional age assumptions#
            IDF<-function(q,FAA,x)#
                {#
                    if (FAA==0)#
                        {#
                            0#
                        }#
                    else if (FAA==1)#
                        {#
                            1#
                        }#
                    else if (FAA==2)#
                        {#
                            x#
                        }#
                    else if (FAA==3)#
                        {#
                            if (q<0.000001)#
                                {#
                                    x+0.5*q*x*(x-1)#
                                }#
                            else if (q==1)#
                                {#
                                    0#
                                }#
                            else#
                                {#
                                    log(1-q*x)/log(1-q)#
                                }#
                        }#
                    else #
                        {#
#
                            (1-q)*x/(1-q*x)#
                        }#
                }#
## Backward Linear First Order Recurrence - takes care of insurance#
## Final boundary value is bv#
## The recurrence is x_n = r_n + s_n * x_{n+1}#
## Handles Annuity & Insurance Recurrence; Fackler; Hattendorff;#
## Must be implemented in C#
#
        BLFOR<-function(r,s,bv)#
            {#
                temp<-bv;#
                dum<-function(x){#
                    temp<<-x[1]+x[2]*temp#
                }#
                as.array(apply(cbind(array(r,dim=length(s)),array(s))[length(s):1,],1,FUN=dum)[length(s):1]);#
            }#
#
## The following function finds the p vector for a given q vector#
## S stands for the survival function and K for the curtate future life time#
#
        SK<-function(q)#
            {#
                temp<-1;#
                dum<-function(x){#
                    temp<<-(1-x)*temp#
                }#
                unlist(lapply(c(0,q),FUN=dum))#
            }#
#
## Fractional Age Assumptions related functions#
## The fractional age assumptions considered are the following :#
##      0 - Degenerate at 0#
##      1 - Degenerate at 1#
##      2 - Uniform(0,1)#
##      3 - Exponential#
##      4 - Hyperboilic#
## The functions defined are the following:#
##      a(q, FAA)#
##          This gives E(T(x)|T(x)<1) - q->q_x - for the FAA#
##          Useful for computing complete future life times#
##      M(q, FAA,interest rate)#
##          This gives E(exp(-\delta T(x))|T(x)<1) - q->q_x - for the FAA and \delta=ln(1+interest rate)#
##          Note that E(exp(-\delta T(x))|T(x)<1)q_x is the APV of a one year term insurance on age x#
##          Note that E(exp(-\delta T(x))|T(x)<1)q_x + \nu*p_x is the APV of a one year endowment insurance on age x#
##          Useful for computing continuous insurances and continuous annuities#
##      am(q,m,FAA,i)#
##          The following function helps in computing one year temporary annuity due payable m-thly under any#
##          of the standard fractional age assumptions. Using it we define below the OYT payable m-thly.#
##      OYT(q,m,FAA,i)#
##          OYT i.e. One Year Term insurance is valued using the function M and the function am#
#
        ##      a(q, FAA)#
        ##          This gives E(T(x)|T(x)<1) - q->q_x - for the FAA#
        ##          Useful for computing complete future life times#
#
                        a<-function(q,FAA)#
                            {#
                                if (FAA==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        0#
                                    }#
                                }#
                                else if (FAA==1)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        1#
                                    }#
                                }#
                                else if (FAA==2)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        0.5#
                                    }#
                                }#
                                else if (FAA==3)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q==1)#
                                        {#
                                            Soln<- 0;#
                                        }#
                                        else if (q<0.000001)#
                                        {#
                                            Soln<- 0.5 - q/12;#
                                        }#
                                        else#
                                        {#
                                            Soln<- -((1-q)/q + 1/log(1-q));#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else if (FAA==4)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q==1)#
                                        {#
                                            Soln<-0#
                                        }#
                                        else if (q<0.000001)#
                                        {#
                                            Soln<-0.5 - q/6#
                                        }#
                                        else#
                                        {#
                                            Soln<- -((1-q)/q^2) * (q + log(1-q))#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        NA#
                                    }#
                                }#
                            unlist(lapply(q,dum))#
                        }#
#
        ##      M(q, FAA,interest rate)#
        ##          This gives E(exp(-\delta T(x))|T(x)<1) - q->q_x - for the FAA and \delta=ln(1+interest rate)#
        ##          Note that E(exp(-\delta T(x))|T(x)<1)q_x is the APV of a one year term insurance on age x#
        ##          Note that E(exp(-\delta T(x))|T(x)<1)q_x + \nu*p_x is the APV of a one year endowment insurance on age x#
        ##          Useful for computing continuous insurances and continuous annuities#
#
                        M<-function(q,FAA,i)#
                            {#
                                if (FAA==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        1#
                                    }#
                                }#
                                else if (FAA==1)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        1/(1+i)#
                                    }#
                                }#
                                else if (FAA==2)#
                                {#
                                    if (i<0.000001 )#
                                    {#
                                        dum<-function(q)#
                                        {#
                                            1-i/2#
                                        }#
                                    }#
                                    else#
                                    {#
                                        dum<-function(q)#
                                        {#
                                            (1-1/(1+i))/log(1+i)#
                                        }#
                                    }#
                                }#
                                else if (FAA==3)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q>0.000001 && q!=1)#
                                        {#
                                            Soln<- -(log(1-q)*(1-(1-q)/(1+i)))/(q*(-log(1-q)+log(1+i)));#
                                        }#
                                        else if (q<1-0.999999*(1+i))#
                                        {#
                                            Soln<- (1+q/2)/(1.5-0.5*(1-q)/(1+i));#
                                        }#
                                        else if (q<0.000001)#
                                        {#
                                            Soln<- (1+q/2)*(1-(1-q)/(1+i));#
                                        }#
                                        else#
                                        {#
                                            Soln<- 1;#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else if (FAA==4)#
                                {#
                                    delta<-log(1+i);#
                                    dum<-function(q)#
                                    {#
                                        if (q>0.99999)#
                                        {#
                                            if (q==1)#
                                            {#
                                                Soln<-1;#
                                            }#
                                            else#
                                            {#
                                                f1<-function(x)#
                                                {#
                                                    (exp(-delta*x)-1+delta*x)/(1-q+q*x)^2#
                                                }#
                                                Soln<1+integrate(f1,0,1)$value*(1-q)+delta*((1-q)/q^2) * (q + log(1-q));#
                                            }#
                                        }#
                                        else#
                                        {#
                                            f2<-function(x)#
                                            {#
                                                exp(-delta*x)/(1-q+q*x)^2#
                                            }#
                                            Soln<-(1-q)*integrate(f2,0,1)$value;#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        NA#
                                    }#
                                }#
                                unlist(lapply(q,dum))#
                            }#
#
        ## The following function helps in computing one year temporary annuity due payable m-thly under any#
        ## of the standard fractional age assumptions. Using it we define below the OYT payable m-thly.#
#
                        am<-function(q,m,FAA,i)#
                        {#
							# Pays 1 annually#
                            delta<-log(1+i);#
                            disc<-i/(1+i);#
                            if (m!=0)#
                            {#
                                im<-m*((1+i)^(1/m)-1);#
                                dm<-m*im/(m+im);#
                            }#
                            if (FAA==0)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        (1-q)*disc/delta#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        q/m+(1-q)*disc/dm#
                                    }#
                                }#
                            }#
                            else if (FAA==1)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        ## Annuity Certain - Continuous#
#
                                        disc/delta#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        ## Annuity Certain - Due payable m-thly#
#
                                        disc/dm#
                                    }#
                                }#
                            }#
                            else if (FAA==2)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        q/delta*(1-disc/delta)+(1-q)*disc/delta#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        q/dm*(1-disc/im)+(1-q)*disc/dm#
                                    }#
                                }#
                            }#
                            else if (FAA==3)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        Soln<-0;#
                                        if ((1-q)/(1+i)!=1)#
                                        {#
                                            Soln<-((1-q)/(1+i)-1)/(log((1-q)/(1+i)));#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        Soln<-1/m;#
                                        if ((1-q)/(1+i)!=1)#
                                        {#
                                            Soln=(1-(1-q)/(1+i))/(m*(1-((1-q)/(1+i))^(1/m)));#
                                        }#
                                        Soln#
                                    }#
#
                                }#
                            }#
                            else if (FAA==4)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q>0.99999)#
                                        {#
                                            if (q==1)#
                                            {#
                                                Soln<-0;#
                                            }#
                                            else#
                                            {#
                                                f1<-function(x)#
                                                {#
                                                    (1-exp(-delta*x)-delta*x)/(1-q+q*x)^2#
                                                }#
                                                Soln<-integrate(f1,0,1)$value*(1-q)/delta-((1-q)/q^2) * (q + log(1-q));#
                                            }#
                                        }#
                                        else#
                                        {#
                                            f2<-function(x)#
                                            {#
                                                exp(-delta*x)/(1-q+q*x)^2#
                                            }#
                                            Soln<-(1-(1-q)/(1+i)-q*(1-q)*integrate(f2,0,1)$value)/delta;#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        Soln<-1;#
                                        for (k in 1:(m-1))#
                                        {#
                                            Soln=Soln+(1-q)/((1-(1-k/m)*q)*(1+im/m)^k)#
                                        }#
                                        Soln/m#
                                    }#
                                }#
                            }#
                            else#
                            {#
                                dum<-function(q)#
                                {#
                                    NA#
                                }#
                            }#
                            unlist(lapply(q,dum))#
                        }#
        ## OYT i.e. One Year Term insurance is valued using the function M and the function am#
                        OYT<-function(q,m,FAA,i) {#
                            if (m!=0) {#
                                dm<-m*(1-(1+i)^(-1/m));#
                                Soln<-1-dm*am(q,m,FAA,i)-(1-q)/(1+i);#
							} else {#
                                Soln<-q*M(q,FAA,i);#
                            }#
                            Soln#
                        }#
###########
# 2014-03-30#
LCcheck.q <- function(q) {#
	if(prod(q>0)==0) {stop("at least one element of q is less than zero")}#
	# else if(q[length(q)]!=1) {warning("the last element in q is not 1")}#
}#
#
LCcheck.FAA <- function(FAA) {#
	if(! FAA %in% c(0,1,2,3,4)) {stop("The fractional age assumption that was entered is not one of the permitted assumptions. They are:#
		0 - Degenerate at 0#
		1 - Degenerate at 1#
		2 - Uniform(0,1)#
		3 - Exponential#
		4 - Hyperboilic")}#
}#
qOY2qmthly_OY <- function(q,m,FAA) {#
	# Converts a single one-year death probabily into a vector of mthly death probabilities#
	# m is the number of periods in each year#
	# h is the length of each period#
	#  the function returns:#
		 # for k = 0, 1, ... , m-1, Pr(T < (k+1)*h | T >= k*h)#
	if(round(m,0)!=m) {warning("m is not an integer, rounding it to the closest integer")}#
		m <- round(m,0)#
	if(m==0) {stop("m can't be zero")}#
	LCcheck.q(q)#
	LCcheck.FAA(FAA)#
	out <- rep(NA, m*length(q))#
	if(FAA==0) {#
		out <- c(q, rep(0, m*length(q)-1))#
	}#
	else if(FAA==1) {#
		out <- c(rep(0, m*length(q)-1), q)#
	}#
	h <- 1/m # h is used in the uniform and exponential fractional age assumptions#
	if(FAA==2) {#
		temp2 <- q*h#
		for (k in 0:(m-1)) {#
			out[k+1] <- temp2/(1 - k*temp2)#
		}#
	}#
	else if(FAA==3) {#
		out <- rep(1 - (1-q)^h, m*length(q))#
	}#
	else if(FAA==4) {#
		stop("The Hyperbolic fractional age assumption is not supported at this time.")#
	}#
	return(out)#
}#
#
qOY2qmthly <- function(q,m,FAA) {#
	# converts a VECTOR of one-year death probabilities to a vector of mthly 1/m duration death probabilities#
	unlist(lapply(q,FUN = function(x) qOY2qmthly_OY(q=x,m=m,FAA=FAA)))#
}#
####
# 2014-05-03#
# Some useful functions#
.ones <- function(temp) {as.array(rep(1, length(temp)))}#
#
.DiscountFact <- function(i, m) {#
	# returns a discount factor based on an anual effective interest rate#
	if(m==0) {stop("The frequency, 'm' can't be zero")} else {#
		out <- NULL#
		out <- {1+i}^-{1/m}#
	}#
	return(out)#
}#
#
BenFactors <- function(OYq, i, PB=PolBasis) {#
	# TODO: change to use OYT, one year term#
	out <- NULL#
	end <- PB$SurvFactor#
	freq <- PB$BenFreq#
	q <- qOY2qmthly(q=OYq, m=freq, FAA=PB$FAA)#
	v <- .DiscountFact(i,m=freq) * .ones(freq*PB$TermDur)#
	out <- BLFOR(q*v, (1-q)*v, end)#
	return(out)#
}#
#
PremFactors <- function(OYq, i, PB=PolBasis) {#
	out <- NULL#
	end <- 0 # not reasonable for them to pay a premium at the end#
	freq <- PB$PremFreq#
	q <- qOY2qmthly(q=OYq, m=freq, FAA=PB$FAA)#
	v <- .DiscountFact(i,m=freq) * .ones(freq*PB$TermDur)#
	out <- BLFOR(.ones(q), (1-q)*v, end)#
	return(out)#
}#
#
.GetPolDur <- function(Date, IssueDate) {#
	out <- NULL#
	out <- Date - IssueDate#
	return(out)#
}#
# get parameter value#
.gpv <- function(df, param, type="numb") {#
	out <- NULL#
	bar <- df[which(df$Parameter==param),"Value"]#
	out <- switch(type, numb=as.numeric(levels(bar)[bar]),#
						char=paste(levels(bar)[bar])#
				)#
	return(out)#
}#
#
.YM2date <- function(year,month) {#
	out <- year + (month - 1)/12#
	return(out)#
}#
#
setProjParams <- function(df) {#
	out <- list()#
	# I'm going to use begining of the month as the standard#
	# i.e., Jan 2015 means 1/1/2015, or 2015.00; 12/31/2014 in some other programs#
	out$PjTimeUnits <- .gpv(df,"ProjTimeUnits","char")#
	out$PjSY <- .gpv(df,"ProjStartYear")#
	out$PjSM <- .gpv(df,"ProjStartMonth")#
	out$PjSD <- .YM2date(out$PjSY,out$PjSM) # as float in years#
	out$PjEY <- .gpv(df,"ProjEndYear")#
	out$PjEM <- .gpv(df,"ProjEndMonth")#
	out$PjED <- .YM2date(out$PjEY,out$PjEM) # as float in years#
	out$PjDur <- out$PjED - out$PjSD # Projection Duration#
	# Projection frequency#
	#  1 <- annual#
	#  2 <- semi-annual#
	#  3 <- every four months#
	#  4 <- quarterly#
	# 12 <- monthly#
	out$PjFreq <- .gpv(df,"ProjFreq")#
	out$PjDates <- seq(out$PjSD,out$PjED,out$PjFreq)#
	out$ProjTimes <- seq(0,out$PjDur,out$PjFreq)#
	return(out)#
}
setwd('/Volumes/amy/LifeCon/non_standard/examples')
q <- c(.3,.4,1)#
f <- SK(q)[1:n]*q#
f#
# it needs to have a terminal age#
sum(SK(q)[1:n]*q)#
f[1]+f[2]#
#
y <- WalkerTable(q)#
y#
sum(y[,1])#
#
set.seed(42)#
RGD(y,k)#
set.seed(42)#
m <- runif(k)#
m[1]#
m[1]*3#
ceiling(m[1]*3)#
y
setwd('/Volumes/amy/LifeCon/LifeCon/R')
tbl <- y#
					k <- 5
setwd('/Volumes/amy/LifeCon/LifeCon/R')
n<-length(tbl[,1]);
setwd('/Volumes/amy/LifeCon/LifeCon/R')
n
setwd('/Volumes/amy/LifeCon/LifeCon/R')
set.seed(42)
setwd('/Volumes/amy/LifeCon/LifeCon/R')
r<-as.array(runif(k));
setwd('/Volumes/amy/LifeCon/LifeCon/R')
r
setwd('/Volumes/amy/LifeCon/LifeCon/R')
l <- 1
setwd('/Volumes/amy/LifeCon/LifeCon/R')
u<-r[l];
setwd('/Volumes/amy/LifeCon/LifeCon/R')
u
setwd('/Volumes/amy/LifeCon/LifeCon/R')
i<-ceiling(n*u);
setwd('/Volumes/amy/LifeCon/LifeCon/R')
i
setwd('/Volumes/amy/LifeCon/LifeCon/R')
tbl[i,1]
setwd('/Volumes/amy/LifeCon/LifeCon/R')
u
setwd('/Volumes/amy/LifeCon/LifeCon/R')
u>=tbl[i,1]
setwd('/Volumes/amy/LifeCon/LifeCon/R')
r[l]=i;
setwd('/Volumes/amy/LifeCon/LifeCon/R')
r[l]
