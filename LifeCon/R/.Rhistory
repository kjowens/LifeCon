0, 0, 0#
),#
nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
c(100, 0, 0,#
0, 0, 0,#
0, 0, 0#
),#
nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
0.01*exp(-0.5*t)#
}#
#
mu23 <- function( t )#
{#
0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
out <- matrix(#
c(0, mu12(t), mu13(t),#
mu21(t), 0, mu23(t),#
0, 0, 0#
),#
nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
c(100, 0, 0,#
0, 0, 0,#
0, 0, 0#
),#
nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
mu21 <- function( t )#
{#
0.01*exp(-0.5*t^2)#
}#
#
mu23 <- function( t )#
{#
0.05 + 0.003*t#
}#
#
mus <- function( t )#
{#
out <- matrix(#
c(0, mu12(t), mu13(t),#
mu21(t), 0, mu23(t),#
0, 0, 0#
),#
nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
return(out)#
}#
#
# Start with 100 healthy people#
p.start <- matrix(#
c(100, 0, 0,#
0, 0, 0,#
0, 0, 0#
),#
nrow=3, ncol=3, byrow=TRUE, dimnames=list(statesNames, statesNames)#
)#
#
myps <- KFE.pijt( horizon=50, h=1, population.start=p.start, ForcesofMort=mus, statesNames=statesNames  )#
#
mus(50)#
#
# Some disabed people become healthy, but eventually most die#
a <- round(myps[,"Healthy",],5)#
a#
plot(a[,2])#
#
#plot(a[,1])#
#plot(a[,3])
library(Rcpp)
Rcpp.package.skeleton("mypackage")
a <- data.frame(x=1:4, y=5:8)
a
a$z <- a
a
b <- list(hi=a, hh=a)
b$hi
b$1
c <- list(a,a)
c
c[1]
b[1]
fun1 <- function(x) x*2
fun1(2)
hi <- list(a=fun1)
hi[1](4)
hi[1]
hi$a(4)
hi
hi[1]
hi[1](4)
hi[[1]](4)
vignette("Rcpp-introduction")
ggkm <- function(sfit,#
table = TRUE,#
returns = FALSE,#
xlabs = "Time",#
ylabs = "Survival Probability",#
xlims = c(0,max(sfit$time)),#
ylims = c(0,1),#
ystratalabs = NULL,#
ystrataname = NULL,#
timeby = 100,#
main = "Kaplan-Meier Plot",#
pval = TRUE,#
subs = NULL,#
...) {#
##############
# libraries ##
##############
require(ggplot2)#
require(survival)#
require(gridExtra)#
##################################
# sorting the use of subsetting ##
##################################
times <- seq(0, max(sfit$time), by = timeby)#
if(is.null(subs)){#
subs1 <- 1:length(levels(summary(sfit)$strata))#
subs2 <- 1:length(summary(sfit,censored=T)$strata)#
subs3 <- 1:length(summary(sfit,times = times,extend = TRUE)$strata)#
} else{#
for(i in 1:length(subs)){#
if(i==1){#
ssvar <- paste("(?=.*\\b=",subs[i],sep="")#
}#
if(i==length(subs)){#
ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],"\\b)",sep="")#
}#
if(!i %in% c(1, length(subs))){#
ssvar <- paste(ssvar,"\\b)(?=.*\\b=",subs[i],sep="")#
}#
if(i==1 & i==length(subs)){#
ssvar <- paste("(?=.*\\b=",subs[i],"\\b)",sep="")#
}#
}#
subs1 <- which(regexpr(ssvar,levels(summary(sfit)$strata), perl=T)!=-1)#
subs2 <- which(regexpr(ssvar,summary(sfit,censored=T)$strata, perl=T)!=-1)#
subs3 <- which(regexpr(ssvar,summary(sfit,times = times,extend = TRUE)$strata, perl=T)!=-1)#
}#
if( !is.null(subs) ) pval <- FALSE#
###################################
# data manipulation pre-plotting ##
###################################
if(is.null(ystratalabs)) ystratalabs <- as.character(sub("group=*","",names(sfit$strata))) #[subs1]#
if(is.null(ystrataname)) ystrataname <- "Strata"#
m <- max(nchar(ystratalabs))#
times <- seq(0, max(sfit$time), by = timeby)#
.df <- data.frame(                      # data to be used in the survival plot#
time = sfit$time[subs2],#
n.risk = sfit$n.risk[subs2],#
n.event = sfit$n.event[subs2],#
surv = sfit$surv[subs2],#
strata = factor(summary(sfit, censored = T)$strata[subs2]),#
upper = sfit$upper[subs2],#
lower = sfit$lower[subs2]#
)#
levels(.df$strata) <- ystratalabs       # final changes to data for survival plot#
zeros <- data.frame(time = 0, surv = 1,#
strata = factor(ystratalabs, levels=levels(.df$strata)),#
upper = 1, lower = 1)#
.df <- rbind.fill(zeros, .df)#
d <- length(levels(.df$strata))#
####################################
# specifying plot parameteres etc ##
####################################
p <- ggplot( .df, aes(time, surv)) +#
geom_step(aes(linetype = strata), size = 0.7) +#
theme_bw() +#
opts(axis.title.x = theme_text(vjust = 0.5)) +#
scale_x_continuous(xlabs, breaks = times, limits = xlims) +#
scale_y_continuous(ylabs, limits = ylims) +#
opts(panel.grid.minor = theme_blank()) +#
opts(legend.position = c(ifelse(m < 10, .28, .35),ifelse(d < 4, .25, .35))) +    # MOVE LEGEND HERE [first is x dim, second is y dim]#
opts(legend.key = theme_rect(colour = NA)) +#
labs(linetype = ystrataname) +#
opts(plot.margin = unit(c(0, 1, .5,ifelse(m < 10, 1.5, 2.5)),"lines")) +#
opts(title = main)#
## Create a blank plot for place-holding#
## .df <- data.frame()#
blank.pic <- ggplot(.df, aes(time, surv)) +#
geom_blank() + theme_bw() +#
opts(axis.text.x = theme_blank(),axis.text.y = theme_blank(),#
axis.title.x = theme_blank(),axis.title.y = theme_blank(),#
axis.ticks = theme_blank(),#
panel.grid.major = theme_blank(),panel.border = theme_blank())#
######################
# p-value placement ##
#####################a#
if(pval) {#
sdiff <- survdiff(eval(sfit$call$formula), data = eval(sfit$call$data))#
pval <- pchisq(sdiff$chisq,length(sdiff$n) - 1,lower.tail = FALSE)#
pvaltxt <- ifelse(pval < 0.0001,"p < 0.0001",paste("p =", signif(pval, 3)))#
p <- p + annotate("text",x = 0.6 * max(sfit$time),y = 0.1,label = pvaltxt)#
}#
####################################################
# Create table graphic to include at-risk numbers ##
####################################################
if(table) {#
risk.data <- data.frame(#
strata = factor(summary(sfit,times = times,extend = TRUE)$strata[subs3]),#
time = summary(sfit,times = times,extend = TRUE)$time[subs3],#
n.risk = summary(sfit,times = times,extend = TRUE)$n.risk[subs3]#
)#
risk.data$strata <- factor(risk.data$strata, levels=rev(levels(risk.data$strata)))#
data.table <- ggplot(risk.data,aes(x = time, y = strata, label = format(n.risk, nsmall = 0))) +#
#, color = strata)) +#
geom_text(size = 3.5) + theme_bw() +#
scale_y_discrete(breaks = as.character(levels(risk.data$strata)),#
labels = rev(ystratalabs)) +#
# scale_y_discrete(#format1ter = abbreviate,#
# breaks = 1:3,#
# labels = ystratalabs) +#
scale_x_continuous("Numbers at risk", limits = xlims) +#
opts(axis.title.x = theme_text(size = 10, vjust = 1),#
panel.grid.major = theme_blank(), panel.grid.minor = theme_blank(),#
panel.border = theme_blank(),axis.text.x = theme_blank(),#
axis.ticks = theme_blank(),axis.text.y = theme_text(face = "bold",hjust = 1))#
data.table <- data.table +#
opts(legend.position = "none") + xlab(NULL) + ylab(NULL)#
data.table <- data.table +#
opts(plot.margin = unit(c(-1.5, 1, 0.1, ifelse(m < 10, 2.5, 3.5) - 0.28 * m), "lines")) # ADJUST POSITION OF TABLE FOR AT RISK#
########################
# Plotting the graphs ##
########################
## p <- ggplotGrob(p)#
## p <- addGrob(p, textGrob(x = unit(.8, "npc"), y = unit(.25, "npc"), label = pvaltxt,#
## gp = gpar(fontsize = 12)))#
grid.arrange(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
ncol = 1, heights = unit(c(2, .1, .25),c("null", "null", "null")))#
if(returns) {#
a <- arrangeGrob(p, blank.pic, data.table, clip = FALSE, nrow = 3,#
ncol = 1, heights = unit(c(2, .1, .25), c("null", "null", "null")))#
return(a)#
}#
} else {#
## p <- ggplotGrob(p)#
## p <- addGrob(p, textGrob(x = unit(0.5, "npc"), y = unit(0.23, "npc"),#
## label = pvaltxt, gp = gpar(fontsize = 12)))#
if(returns) return(p)#
}#
}
a <- list(1:2, 3:4)
a
a[]
a[][1]
a[][1] <- 5:6
a[][1]
a
a <- list(1:2, 3:4)
a
a[][1]
a[,1]
3*4*5
a <- array(1:60, dims=c(3,4,5))
a <- as.array(1:60, dims=c(3,4,5))
a
?array
a <- as.array(1:60, dim=c(3,4,5))
a
a[1,,]
a[1,]
is.array(a)
dims(a)
dim(a)
a <- array(1:60, dim=c(3,4,5))
a
dim(a)
dimnames(a)
dimnames(a) <- list(x=letters(1:3),y=letters(1:4),z=letters(1:5))
?letters
letters(1)
letter(1)
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
a
a[b,a,a]
a["b","a","a"]
?paste
paste(1)
paste(a)
a$x
a[x=="b"]
a
a["a",,]
4 %.% 5
a[1,,]
a[2,,]
paste(pi)
a[2,,] <- 1:20
a[2,,]
a[,3,]
a[y=3,,]
a[y==3,,]
dimnames(a)
a$x
a
a[y=2]
y
a <- array(1:60, dim=c(3,4,5))#
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
a
a <- array(1:60, dim=c(3,4,5))#
dimnames(a) <- list(x=letters[1:3],y=letters[1:4],z=letters[1:5])
dimnames(a)
a["y"]
a[y]
a[y,,]
a["y",,]
a
a["y",,]
a["a",,]
a[]
a[]$x
dimnames(a)
dimnames(a)$x
z <- list(matrix(1:10, nrow=2), matrix(11:20, nrow=2))#
lapply(z, "[", 1, )#
lapply(z, "[", , 3)
z[1]
z[2]
z <- list(a=matrix(1:10, nrow=2), b=matrix(11:20, nrow=2))
lapply(z, "[", 1, )
z <- list(a=data.frame(1:10, nrow=2), b=data.frame(11:20, nrow=2))
z
z <- list(a=matrix(1:10, nrow=2), b=matrix(11:20, nrow=2))
lapply(z, "$", 1, )
lapply(z, "$", "a", )
lapply(z, "$", "a")
z$a
as.data.frame(z$a)
z$a <- as.data.frame(z$a)
z$b <- as.data.frame(z$b)
z
lapply(z, "$", V1)
lapply(z, "$", "V1")
lapply(z, "$")
z
lapply(z, "$",1)
lapply(z, "$","1")
lapply(z, "[",V2)
lapply(z, "[","V2")
lapply(z, "[",1,)
lapply(z, "[",where(right("V1",1)==4))
lapply(z, "[",which(right("V1",1)==4))
??right
mod(4,2)
modulus(4,2)
??mod
is.even(2)
lapply(z, "[",which(right("V1",1)>3))
lapply(z, "[",which("V1">3))
z
lapply(z, "[","V1">2)
z$a[which(z$a>1)]
z$a[which(z$a["V1"]>1)]
502*40*(9.24-7.25)
52*40*(9.24-7.25)
52*40*(9.24-7.25)*.9
library(lifecontingencies)
x <- 1:10#
q <- rep(.2, length(x))#
df <- as.dataframe(cbind(x,q))#
df
df <- data.frame(cbind(x,q))#
df
as.lifetable(df)
x <- 1:10#
lx <- seq(100,0,20)#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
lx <- seq(100,0,-20)#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
x#
lx
x <- 1:10#
lx <- seq(100,0,-10)#
x#
lx#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
x <- 1:10#
lx <- seq(100,10,-10)#
x#
lx#
tbl <- new("lifetable",x=x, lx=lx)#
tbl
(x)
length(x)
length(lx)
tbl
tbl <- new("lifetable",x lx)
tbl <- new("lifetable",x, lx)
library(lifecontingencies)
x <- 1:10#
lx <- seq(100,10,-10)#
length(x)#
length(lx)#
tbl <- new("lifetable",x, lx)#
tbl
x <- 1:3#
lx <- c(100,50,0)#
length(x)#
length(lx)#
tbl <- new("lifetable",x, lx)#
tbl
soa08
tbllist <- list(tbl, tbl, tbl)
pxt(tbl, x=age)
age <- 90#
pxt(tbl, x=age)
pxt(tbl, x=age, t=1)
library(lifecontingencies)
pxt(tbl, x=age, t=1)
qxt(tbl, x=age, t=1)
tbl
tbl <- soa08#
tbllist <- list(tbl, tbl, tbl)#
age <- 90#
qxt(tbl, x=age, t=1)
pxt(tbl, x=age, t=1)
tbllist <- list(tbl, tbl)#
age <- 100#
pxt(tbl, x=age, t=1)
agelist <- list(age, age)
pxyzt(tbllist, agelist, t=1, status="last survivor")
ages <- c(age, age)#
pxyzt(tbllist, ages, t=1, status="last survivor")
pxyt(tbl, tbl, age, age, t=1, status="last survivor")
qxt(tbl, x=age, t=1)
y <- pxt(tbl, x=age, t=1)
y
2*y - y^2
pxyzt(tbllist3, ages3, t=1, status="last survivor")
ages3 <- c(age, age, age)#
tbllist3 <- list(tbl, tbl, tbl)#
pxyzt(tbllist3, ages3, t=1, status="last survivor")
3*y - 3*y^2 + y^3
help(apply)
mapply(rep, 1:4, 4:1)
X <- list(list(a = pi, b = list(c = 1:1)), d = "a test")#
rapply(X, function(x) x, how = "replace")
x <- list(1:4)
x
rapply(x, sqrt)
x
rapply(x, sqrt, how="replace")#
x
x <- list(1:4, list(5:8))#
x#
rapply(x, sqrt, how="replace")#
x
x <- list(list(1:4), list(5:8))#
x#
rapply(x, sqrt, how="replace")#
x
lapply(x, sqrt)
rapply(x, sqrt, how="list")
mapply(rep, 1:4, 4:1)
help(rep)
mapply(rep, x=1:4, times=4:1)
mapply(rep, times=1:4, x=4:1)
help("attributes")
a <- 1:5
a
class(a)
attributes(a) <- list(hi="hi")
a
attributes(a)
attributes(a)$hi
pnorm(-.2853)
pnorm(-.29)
pnorm(.71)
setwd('/Volumes/hd500/LifeCon/LifeCon/R')
## The following two functions help simulate K (and hence T)#
## The first function finds the Huffman optimal tree for a given discrete distribution#
## The second function simulates a random vector of size k from the distribution which#
## corresponds to the given Huffman tree.#
#
        ## The following function finds the Huffman optimal tree for a given discrete distribution#
        ## To be used only once for a given mortality table#
#
            HuffmanCode<-function(f)#
                {#
                    n<-dim(f);#
                    Node<-n;#
                    Forest<-cbind(f,1:n);#
                    Tree<-array(0,c(n,4));#
                    Parents<-array(0,c(3*n,20))#
                    NP<-array(1,3*n);#
                    Tree[1:dim(f),4]=f;#
                    while (n>1)#
                    {#
                        x<-order(Forest[,1])[1:2];#
                        Tree<-rbind(Tree,array(c(Forest[x[1],2],Forest[x[2],2],0,Forest[x[1],1]+Forest[x[2],1]),c(1,4)));#
                        Node=Node+1;#
                            Tree[Forest[x[1],2],3]=Node;#
                            Tree[Forest[x[2],2],3]=Node;#
                            Tree[Forest[x[2],2],4]=Forest[x[1],1]+Forest[x[2],1];#
                            Parents[Forest[x[1],2],NP[Forest[x[1],2]]]=Node;#
                            NP[Forest[x[1],2]]=NP[Forest[x[1],2]]+1;#
                            Parents[Forest[x[2],2],NP[Forest[x[2],2]]]=Node;#
                            NP[Forest[x[2],2]]=NP[Forest[x[2],2]]+1;#
                        for (k in 1:Node)#
                        {#
                            if ((any(Parents[k,]==Forest[x[1],2])) || (any(Parents[k,]==Forest[x[2],2])))#
                            {#
                                Parents[k,NP[k]]=Node;#
                                NP[k]=NP[k]+1;#
                                if (any(Parents[k,]==Forest[x[2],2]))#
                                {#
                                    Tree[k,4]=Tree[k,4]+Forest[x[1],1];#
                                }#
                            }#
                        }   #
                        Forest[x[1],]<-array(c(Forest[x[1],1]+Forest[x[2],1],Node),c(1,2));#
                        n=n-1;#
                        Forest<-array(Forest[Forest[,1]!=Forest[x[2],1]],c(n,2));#
                    }#
                    Tree#
                }#
#
        ## The following function builds the tables for the Alias Method of Walker#
            WalkerTable<-function(f)#
                {#
					# f <- SK(q)[1:n]*q#
                    F<-cbind(length(f)*f,1:length(f));#
                    L<-array(0,length(f));#
                    while (length(F[(F[,1]<1)&(F[,1]>0),1])>0) #
                        {#
                            j<-F[(F[,1]<1)&(F[,1]>0),2][1];#
                            k<-F[F[,1]>=1,2][1];#
                            L[j]=k;#
                            F[k,1]=F[k,1]-1+F[j,1];#
                            F[j,1]= - F[j,1];#
                        }#
                    cbind((F[,2]-abs(F[,1]))/length(f),L)#
                }#
#
        ## The following function simulates from a general discrete distribution using the alias method of Walker.#
            RGD<-function(tbl,k)#
                {#
                    n<-length(tbl[,1]);#
                    r<-as.array(runif(k));#
                    for (l in 1:k)#
                    {#
                        u<-r[l];#
                        i<-ceiling(n*u);#
                        if (u>=tbl[i,1]) {#
                            r[l]=i;#
                        }#
                        else {#
                            r[l]=tbl[i,2];#
                            }#
                    }#
                    r#
                }#
#
        ## The following function simulates a random vector of size k from the distribution which#
        ## corresponds to the given Huffman tree. Huffman tree can be found using the above function#
        ## and in fact the two can be combined as#
        ##                                          RGD(HuffmanCode(f),k)#
        ###
#
            RGDHuffman<-function(Tree,k)#
                {#
                    n<-length(Tree)/4;#
                    m<-length(Tree[Tree[,1]==0])/4;#
                    HuffmanDecode<-function(r)#
                        {#
                            nn<-n;#
                            while (nn>m)#
                            {#
                                if (r<Tree[Tree[nn,1],4])#
                                {#
                                    nn=Tree[nn,1];#
                                }#
                                else#
                                {#
                                    nn=Tree[nn,2];#
                                }#
                            }#
                            nn#
                        }#
                    r<-as.array(runif(k));#
                    for (l in 1:k)#
                    {#
                       r[l]<-HuffmanDecode(r[l]);#
                    }#
                    r                        #
                }#
#
        ## The following function simulates from a general discrete distribution using the alias method of Walker.#
            RT<-function(q,FAA,k)#
                {#
                    n<-length(q);#
                    T<-WalkerTable(SK(q)[1:n]*q);#
                    r<-as.array(runif(k));#
                    for (l in 1:k)#
                    {#
                        u<-r[l];#
                        i<-ceiling(n*u);#
                        if (u>=T[i,1]) {#
                            r[l]=i-1+IDF(q[i],FAA,(u-T[i,1])/(1-T[i,1]));#
                        }#
                        else {#
                            r[l]=T[i,2]-1+IDF(q[T[i,2]],FAA,u/T[i,1]);#
                            }#
                    }#
                    r   #
                }#
#
        ## Inverse Distribution Function for fractional age assumptions#
            IDF<-function(q,FAA,x)#
                {#
                    if (FAA==0)#
                        {#
                            0#
                        }#
                    else if (FAA==1)#
                        {#
                            1#
                        }#
                    else if (FAA==2)#
                        {#
                            x#
                        }#
                    else if (FAA==3)#
                        {#
                            if (q<0.000001)#
                                {#
                                    x+0.5*q*x*(x-1)#
                                }#
                            else if (q==1)#
                                {#
                                    0#
                                }#
                            else#
                                {#
                                    log(1-q*x)/log(1-q)#
                                }#
                        }#
                    else #
                        {#
#
                            (1-q)*x/(1-q*x)#
                        }#
                }#
## Backward Linear First Order Recurrence - takes care of insurance#
## Final boundary value is bv#
## The recurrence is x_n = r_n + s_n * x_{n+1}#
## Handles Annuity & Insurance Recurrence; Fackler; Hattendorff;#
## Must be implemented in C#
#
        BLFOR<-function(r,s,bv)#
            {#
                temp<-bv;#
                dum<-function(x){#
                    temp<<-x[1]+x[2]*temp#
                }#
                as.array(apply(cbind(array(r,dim=length(s)),array(s))[length(s):1,],1,FUN=dum)[length(s):1]);#
            }#
#
## The following function finds the p vector for a given q vector#
## S stands for the survival function and K for the curtate future life time#
#
        SK<-function(q)#
            {#
                temp<-1;#
                dum<-function(x){#
                    temp<<-(1-x)*temp#
                }#
                unlist(lapply(c(0,q),FUN=dum))#
            }#
#
## Fractional Age Assumptions related functions#
## The fractional age assumptions considered are the following :#
##      0 - Degenerate at 0#
##      1 - Degenerate at 1#
##      2 - Uniform(0,1)#
##      3 - Exponential#
##      4 - Hyperboilic#
## The functions defined are the following:#
##      a(q, FAA)#
##          This gives E(T(x)|T(x)<1) - q->q_x - for the FAA#
##          Useful for computing complete future life times#
##      M(q, FAA,interest rate)#
##          This gives E(exp(-\delta T(x))|T(x)<1) - q->q_x - for the FAA and \delta=ln(1+interest rate)#
##          Note that E(exp(-\delta T(x))|T(x)<1)q_x is the APV of a one year term insurance on age x#
##          Note that E(exp(-\delta T(x))|T(x)<1)q_x + \nu*p_x is the APV of a one year endowment insurance on age x#
##          Useful for computing continuous insurances and continuous annuities#
##      am(q,m,FAA,i)#
##          The following function helps in computing one year temporary annuity due payable m-thly under any#
##          of the standard fractional age assumptions. Using it we define below the OYT payable m-thly.#
##      OYT(q,m,FAA,i)#
##          OYT i.e. One Year Term insurance is valued using the function M and the function am#
#
        ##      a(q, FAA)#
        ##          This gives E(T(x)|T(x)<1) - q->q_x - for the FAA#
        ##          Useful for computing complete future life times#
#
                        a<-function(q,FAA)#
                            {#
                                if (FAA==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        0#
                                    }#
                                }#
                                else if (FAA==1)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        1#
                                    }#
                                }#
                                else if (FAA==2)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        0.5#
                                    }#
                                }#
                                else if (FAA==3)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q==1)#
                                        {#
                                            Soln<- 0;#
                                        }#
                                        else if (q<0.000001)#
                                        {#
                                            Soln<- 0.5 - q/12;#
                                        }#
                                        else#
                                        {#
                                            Soln<- -((1-q)/q + 1/log(1-q));#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else if (FAA==4)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q==1)#
                                        {#
                                            Soln<-0#
                                        }#
                                        else if (q<0.000001)#
                                        {#
                                            Soln<-0.5 - q/6#
                                        }#
                                        else#
                                        {#
                                            Soln<- -((1-q)/q^2) * (q + log(1-q))#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        NA#
                                    }#
                                }#
                            unlist(lapply(q,dum))#
                        }#
#
        ##      M(q, FAA,interest rate)#
        ##          This gives E(exp(-\delta T(x))|T(x)<1) - q->q_x - for the FAA and \delta=ln(1+interest rate)#
        ##          Note that E(exp(-\delta T(x))|T(x)<1)q_x is the APV of a one year term insurance on age x#
        ##          Note that E(exp(-\delta T(x))|T(x)<1)q_x + \nu*p_x is the APV of a one year endowment insurance on age x#
        ##          Useful for computing continuous insurances and continuous annuities#
#
                        M<-function(q,FAA,i)#
                            {#
                                if (FAA==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        1#
                                    }#
                                }#
                                else if (FAA==1)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        1/(1+i)#
                                    }#
                                }#
                                else if (FAA==2)#
                                {#
                                    if (i<0.000001 )#
                                    {#
                                        dum<-function(q)#
                                        {#
                                            1-i/2#
                                        }#
                                    }#
                                    else#
                                    {#
                                        dum<-function(q)#
                                        {#
                                            (1-1/(1+i))/log(1+i)#
                                        }#
                                    }#
                                }#
                                else if (FAA==3)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q>0.000001 && q!=1)#
                                        {#
                                            Soln<- -(log(1-q)*(1-(1-q)/(1+i)))/(q*(-log(1-q)+log(1+i)));#
                                        }#
                                        else if (q<1-0.999999*(1+i))#
                                        {#
                                            Soln<- (1+q/2)/(1.5-0.5*(1-q)/(1+i));#
                                        }#
                                        else if (q<0.000001)#
                                        {#
                                            Soln<- (1+q/2)*(1-(1-q)/(1+i));#
                                        }#
                                        else#
                                        {#
                                            Soln<- 1;#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else if (FAA==4)#
                                {#
                                    delta<-log(1+i);#
                                    dum<-function(q)#
                                    {#
                                        if (q>0.99999)#
                                        {#
                                            if (q==1)#
                                            {#
                                                Soln<-1;#
                                            }#
                                            else#
                                            {#
                                                f1<-function(x)#
                                                {#
                                                    (exp(-delta*x)-1+delta*x)/(1-q+q*x)^2#
                                                }#
                                                Soln<1+integrate(f1,0,1)$value*(1-q)+delta*((1-q)/q^2) * (q + log(1-q));#
                                            }#
                                        }#
                                        else#
                                        {#
                                            f2<-function(x)#
                                            {#
                                                exp(-delta*x)/(1-q+q*x)^2#
                                            }#
                                            Soln<-(1-q)*integrate(f2,0,1)$value;#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        NA#
                                    }#
                                }#
                                unlist(lapply(q,dum))#
                            }#
#
        ## The following function helps in computing one year temporary annuity due payable m-thly under any#
        ## of the standard fractional age assumptions. Using it we define below the OYT payable m-thly.#
#
                        am<-function(q,m,FAA,i)#
                        {#
							# Pays 1 annually#
                            delta<-log(1+i);#
                            disc<-i/(1+i);#
                            if (m!=0)#
                            {#
                                im<-m*((1+i)^(1/m)-1);#
                                dm<-m*im/(m+im);#
                            }#
                            if (FAA==0)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        (1-q)*disc/delta#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        q/m+(1-q)*disc/dm#
                                    }#
                                }#
                            }#
                            else if (FAA==1)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        ## Annuity Certain - Continuous#
#
                                        disc/delta#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        ## Annuity Certain - Due payable m-thly#
#
                                        disc/dm#
                                    }#
                                }#
                            }#
                            else if (FAA==2)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        q/delta*(1-disc/delta)+(1-q)*disc/delta#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        q/dm*(1-disc/im)+(1-q)*disc/dm#
                                    }#
                                }#
                            }#
                            else if (FAA==3)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        Soln<-0;#
                                        if ((1-q)/(1+i)!=1)#
                                        {#
                                            Soln<-((1-q)/(1+i)-1)/(log((1-q)/(1+i)));#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        Soln<-1/m;#
                                        if ((1-q)/(1+i)!=1)#
                                        {#
                                            Soln=(1-(1-q)/(1+i))/(m*(1-((1-q)/(1+i))^(1/m)));#
                                        }#
                                        Soln#
                                    }#
#
                                }#
                            }#
                            else if (FAA==4)#
                            {#
                                if (m==0)#
                                {#
                                    dum<-function(q)#
                                    {#
                                        if (q>0.99999)#
                                        {#
                                            if (q==1)#
                                            {#
                                                Soln<-0;#
                                            }#
                                            else#
                                            {#
                                                f1<-function(x)#
                                                {#
                                                    (1-exp(-delta*x)-delta*x)/(1-q+q*x)^2#
                                                }#
                                                Soln<-integrate(f1,0,1)$value*(1-q)/delta-((1-q)/q^2) * (q + log(1-q));#
                                            }#
                                        }#
                                        else#
                                        {#
                                            f2<-function(x)#
                                            {#
                                                exp(-delta*x)/(1-q+q*x)^2#
                                            }#
                                            Soln<-(1-(1-q)/(1+i)-q*(1-q)*integrate(f2,0,1)$value)/delta;#
                                        }#
                                        Soln#
                                    }#
                                }#
                                else#
                                {#
                                    dum<-function(q)#
                                    {#
                                        Soln<-1;#
                                        for (k in 1:(m-1))#
                                        {#
                                            Soln=Soln+(1-q)/((1-(1-k/m)*q)*(1+im/m)^k)#
                                        }#
                                        Soln/m#
                                    }#
                                }#
                            }#
                            else#
                            {#
                                dum<-function(q)#
                                {#
                                    NA#
                                }#
                            }#
                            unlist(lapply(q,dum))#
                        }#
        ## OYT i.e. One Year Term insurance is valued using the function M and the function am#
                        OYT<-function(q,m,FAA,i) {#
                            if (m!=0) {#
                                dm<-m*(1-(1+i)^(-1/m));#
                                Soln<-1-dm*am(q,m,FAA,i)-(1-q)/(1+i);#
							} else {#
                                Soln<-q*M(q,FAA,i);#
                            }#
                            Soln#
                        }#
###########
# 2014-03-30#
LCcheck.q <- function(q) {#
	if(prod(q>0)==0) {stop("at least one element of q is less than zero")}#
	# else if(q[length(q)]!=1) {warning("the last element in q is not 1")}#
}#
#
LCcheck.FAA <- function(FAA) {#
	if(! FAA %in% c(0,1,2,3,4)) {stop("The fractional age assumption that was entered is not one of the permitted assumptions. They are:#
		0 - Degenerate at 0#
		1 - Degenerate at 1#
		2 - Uniform(0,1)#
		3 - Exponential#
		4 - Hyperboilic")}#
}#
qOY2qmthly_OY <- function(q,m,FAA) {#
	# Converts a single one-year death probabily into a vector of mthly death probabilities#
	# m is the number of periods in each year#
	# h is the length of each period#
	#  the function returns:#
		 # for k = 0, 1, ... , m-1, Pr(T < (k+1)*h | T >= k*h)#
	if(round(m,0)!=m) {warning("m is not an integer, rounding it to the closest integer")}#
		m <- round(m,0)#
	if(m==0) {stop("m can't be zero")}#
	LCcheck.q(q)#
	LCcheck.FAA(FAA)#
	out <- rep(NA, m*length(q))#
	if(FAA==0) {#
		out <- c(q, rep(0, m*length(q)-1))#
	}#
	else if(FAA==1) {#
		out <- c(rep(0, m*length(q)-1), q)#
	}#
	h <- 1/m # h is used in the uniform and exponential fractional age assumptions#
	if(FAA==2) {#
		temp2 <- q*h#
		for (k in 0:(m-1)) {#
			out[k+1] <- temp2/(1 - k*temp2)#
		}#
	}#
	else if(FAA==3) {#
		out <- rep(1 - (1-q)^h, m*length(q))#
	}#
	else if(FAA==4) {#
		stop("The Hyperbolic fractional age assumption is not supported at this time.")#
	}#
	return(out)#
}#
#
qOY2qmthly <- function(q,m,FAA) {#
	# converts a VECTOR of one-year death probabilities to a vector of mthly 1/m duration death probabilities#
	unlist(lapply(q,FUN = function(x) qOY2qmthly_OY(q=x,m=m,FAA=FAA)))#
}#
####
# 2014-05-03#
# Some useful functions#
.ones <- function(temp) {as.array(rep(1, length(temp)))}#
#
.DiscountFact <- function(i, m) {#
	# returns a discount factor based on an anual effective interest rate#
	if(m==0) {stop("The frequency, 'm' can't be zero")} else {#
		out <- NULL#
		out <- {1+i}^-{1/m}#
	}#
	return(out)#
}#
#
BenFactors <- function(OYq, i, PB=PolBasis) {#
	# TODO: change to use OYT, one year term#
	# policy holder pv benefit factors#
	out <- NULL#
	end <- PB$SurvFactor # 0 for term, 1 for WL, endowment ins.#
	freq <- PB$BenFreq#
	q <- qOY2qmthly(q=OYq, m=freq, FAA=PB$FAA)#
	v <- .DiscountFact(i,m=freq) * .ones(freq*PB$TermDur)#
	out <- BLFOR(q*v, (1-q)*v, end)#
	return(out)#
}#
#
BenFactors2 <- function(OYq, i, PB=PolBasis) {#
	# TODO: change to use OYT, one year term#
	# policy holder pv benefit factors#
	out <- NULL#
	end <- PB$SurvFactor # 0 for term, 1 for WL, endowment ins.#
	freq <- PB$BenFreq#
	q <- qOY2qmthly(q=OYq, m=freq, FAA=PB$FAA)#
	v <- .DiscountFact(i,m=freq) * .ones(freq*PB$TermDur)#
	out <- BLFOR(q*v, (1-q)*v, end)#
	return(out)#
}#
PremFactors <- function(OYq, i, PB=PolBasis) {#
	out <- NULL#
	end <- 0 # not reasonable for them to pay a premium at the end#
	freq <- PB$PremFreq#
	q <- qOY2qmthly(q=OYq, m=freq, FAA=PB$FAA)#
	v <- .DiscountFact(i,m=freq) * .ones(freq*PB$TermDur)#
	out <- BLFOR(.ones(q), (1-q)*v, end)#
	return(out)#
}#
#
.GetPolDur <- function(Date, IssueDate) {#
	out <- NULL#
	out <- Date - IssueDate#
	return(out)#
}#
.gpv <- function(df, param, type="numb") {#
	# get parameter value#
	out <- NULL#
	bar <- df[which(df$Parameter==param),"Value"]#
	out <- switch(type, numb=as.numeric(levels(bar)[bar]),#
						char=paste(levels(bar)[bar])#
				)#
	return(out)#
}#
#
.YM2date <- function(year,month) {#
	out <- year + (month - 1)/12#
	return(out)#
}#
#
setProjParams <- function(df) {#
	out <- list()#
	# I'm going to use begining of the month as the standard#
	# i.e., Jan 2015 means 1/1/2015, or 2015.00; 12/31/2014 in some other programs#
	out$PjTimeUnits <- .gpv(df,"ProjTimeUnits","char")#
	out$PjSY <- .gpv(df,"ProjStartYear")#
	out$PjSM <- .gpv(df,"ProjStartMonth")#
	out$PjSD <- .YM2date(out$PjSY,out$PjSM) # as float in years#
	out$PjEY <- .gpv(df,"ProjEndYear")#
	out$PjEM <- .gpv(df,"ProjEndMonth")#
	out$PjED <- .YM2date(out$PjEY,out$PjEM) # as float in years#
	out$PjDur <- out$PjED - out$PjSD # Projection Duration#
	# Projection frequency#
	#  1 <- annual#
	#  2 <- semi-annual#
	#  3 <- every four months#
	#  4 <- quarterly#
	# 12 <- monthly#
	out$PjFreq <- .gpv(df,"ProjFreq")#
	out$PjDates <- seq(out$PjSD,out$PjED,out$PjFreq)#
	out$ProjTimes <- seq(0,out$PjDur,out$PjFreq)#
	return(out)#
}
ages <- seq(25, 50, 5)#
q<-Tb(15006)$Values$Aggregate;#
x<-30;n<-30;i<-.04;delta<-log(1+i);d<-i/(1+i);#
par(col="#6C7EBB",mai=c(0.25,.5,.5,.25),lwd=1,lty=1,pch="*");#
layout(matrix(c(1,1,1:5,5,5),3,3,byrow=TRUE))#
## Whole Life#
    qd<-q[(x+1):101];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),0);#
    plot((0:(100-x)),V,xlab=NA,ylab=NA,type="b",#
            main=paste("Whole Life on (",x,")",sep=""));#
## Endowment#
    qd<-q[(x+1):(x+n)];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),1)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),1);#
    MATV<-V;#
    plot((0:(n-1)),V,xlab=NA,ylab=NA,type="b",#
            main=paste(n," Yr.Endowment on (",x,")",sep=""));#
## Term Insurance#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)
setwd('/Volumes/hd500/LifeCon/non_standard/examples')
source("/Volumes/hd500/LifeCon/LifeCon/R/Actuarial.R")#
#
SOAtbl2df.agg <- function(tblnumb, param=list(must.die=FALSE)) {#
	# retrieves aggregate table from SOA website, then converts to data frame#
	# age column is called x, one year death probabilities called qx#
	require(XML)#
	out <- NULL#
	url <- paste("http://mort.soa.org/data/t",tblnumb,".xml",sep="")#
	tempxml <- xmlParse(url)#
	lhi <- xmlToList(tempxml)#
	lhi2 <- lhi[2]$Table$Values$Axis#
	dum2 <- function(.obj, i) {#
		out2 <- list()#
		temp1 <- .obj[i]$Y#
		out2$x  <- as.numeric(temp1$.attrs)#
		out2$qx <- as.numeric(temp1$text)#
		return(out2)#
	}#
	indecies <- 1:length(lhi2)#
	myMorArgs <- list(.obj=lhi2)#
	out <- data.frame(t(mapply(dum2, i=indecies, MoreArgs=myMorArgs)))#
	if(param$must.die==TRUE){ # sets the last qx equal to 1#
		if(out[length(out[,1]),2]!=1){#
			out[length(out[,1]),2] <- 1#
		}#
	}#
	cust.att.agg <- function(tbl, ...) {#
		attributes(tbl)$row.names <- paste(tbl$x)#
		ltemp <- list()#
		ltemp$age.min <- min(unlist(tbl$x))#
		ltemp$age.max <- max(unlist(tbl$x))#
		ltemp$omega <- min(unlist(tbl[which(tbl$qx==1),1]))#
		ltemp$ContentClassification <- lhi$ContentClassification#
		attributes(tbl) <- append(attributes(tbl), ltemp)#
	}#
	attributes(out) <- cust.att.agg(out)#
	if(max(unlist(out$qx))>1){#
		warning("at least one age has a qx greater than 1")#
	}#
	return(out)#
}#
#
tbl <- SOAtbl2df.agg(1585)#
tbl
tbl <- SOAtbl2df.agg(15006)#
tbl
q<-tbl$q;#
x<-30;n<-30;i<-.04;delta<-log(1+i);d<-i/(1+i);#
par(col="#6C7EBB",mai=c(0.25,.5,.5,.25),lwd=1,lty=1,pch="*");#
layout(matrix(c(1,1,1:5,5,5),3,3,byrow=TRUE))#
## Whole Life#
    qd<-q[(x+1):101];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),0);#
    plot((0:(100-x)),V,xlab=NA,ylab=NA,type="b",#
            main=paste("Whole Life on (",x,")",sep=""));#
## Endowment#
    qd<-q[(x+1):(x+n)];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),1)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),1);#
    MATV<-V;#
    plot((0:(n-1)),V,xlab=NA,ylab=NA,type="b",#
            main=paste(n," Yr.Endowment on (",x,")",sep=""));#
## Term Insurance#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)
q<-tbl$qx;#
x<-30;n<-30;i<-.04;delta<-log(1+i);d<-i/(1+i);#
par(col="#6C7EBB",mai=c(0.25,.5,.5,.25),lwd=1,lty=1,pch="*");#
layout(matrix(c(1,1,1:5,5,5),3,3,byrow=TRUE))#
## Whole Life#
    qd<-q[(x+1):101];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),0);#
    plot((0:(100-x)),V,xlab=NA,ylab=NA,type="b",#
            main=paste("Whole Life on (",x,")",sep=""));#
## Endowment#
    qd<-q[(x+1):(x+n)];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),1)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),1);#
    MATV<-V;#
    plot((0:(n-1)),V,xlab=NA,ylab=NA,type="b",#
            main=paste(n," Yr.Endowment on (",x,")",sep=""));#
## Term Insurance#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)
q<-tbl$qx;
q<-tbl$qx;
x<-30;n<-30;i<-.04;delta<-log(1+i);d<-i/(1+i);
par(col="#6C7EBB",mai=c(0.25,.5,.5,.25),lwd=1,lty=1,pch="*");
layout(matrix(c(1,1,1:5,5,5),3,3,byrow=TRUE))
## Whole Life
qd<-q[(x+1):101];
Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/
BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];
Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];
qd/(1+i)
qd
q<-unlist(tbl$qx);#
x<-30;n<-30;i<-.04;delta<-log(1+i);d<-i/(1+i);#
par(col="#6C7EBB",mai=c(0.25,.5,.5,.25),lwd=1,lty=1,pch="*");#
layout(matrix(c(1,1,1:5,5,5),3,3,byrow=TRUE))#
## Whole Life#
    qd<-q[(x+1):101];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),0);#
    plot((0:(100-x)),V,xlab=NA,ylab=NA,type="b",#
            main=paste("Whole Life on (",x,")",sep=""));#
## Endowment#
    qd<-q[(x+1):(x+n)];#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),1)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)-Premium,(1-qd)/(1+i),1);#
    MATV<-V;#
    plot((0:(n-1)),V,xlab=NA,ylab=NA,type="b",#
            main=paste(n," Yr.Endowment on (",x,")",sep=""));#
## Term Insurance#
    Premium<-BLFOR(qd/(1+i),(1-qd)/(1+i),0)[1]/#
                BLFOR(array(1,length(qd)),(1-qd)/(1+i),0)[1];#
    V<-BLFOR(qd/(1+i)
)
